<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Pura Power Pink Pong MVP</title>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
<style>
:root{--pink:#ff69b4;--hot:#ff1493;--bg:#111;--canvas-bg:#222}
body { margin: 0; background:#050507; color:#fff; font-family:'Share Tech Mono', system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; padding-top: 44px; overflow: visible; }
.wrapper{position:relative;padding-top:12px;overflow:visible}
canvas { display:block; margin: 18px auto 0; background:#0b0b10; border:3px solid #ff69b4; border-radius:14px; }
.topbar{display:none}
.info{display:none}

  /* external UI under game (keeps playfield clean) */
  .gameui{max-width:780px;width:100%;margin:14px auto 0;text-align:center;color:#fff;
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;}
  .ui-title{font-weight:700;letter-spacing:0.18em;font-size:14px;color:#ff69b4}
  .ui-subtitle{font-weight:800;letter-spacing:0.10em;font-size:22px;margin-top:6px}
  .ui-meta{opacity:0.7;font-size:12px;margin-top:6px}
  .ui-box{display:inline-block;text-align:left;margin-top:12px;padding:12px 14px;
    background:rgba(0,0,0,0.55);border:1px solid rgba(255,255,255,0.18);border-radius:10px}
  .ui-box-title{font-weight:700;font-size:12px;letter-spacing:0.12em;text-align:center;margin-bottom:8px}
  .ui-box-body{font-size:12px;line-height:1.7}
  .ui-box-body span{opacity:0.85}
  .ui-box-body b{font-weight:800}
  .ui-box-body .dim{opacity:0.55}
  .ui-copy{opacity:0.6;font-size:11px;margin-top:10px}


  html, body { height: 100%; }
  body { margin: 0; padding-top: 24px; overflow: visible; }
  #gameContainer { padding-top: 12px; }
  canvas { display:block; margin-top: 12px; }
</style>
</head>

<body>
<div class="wrapper">
<canvas id="gameCanvas" width="720" height="720" tabindex="0"></canvas>

  <div id="gameUI" class="gameui">
    <div class="ui-title">PINK PONG</div>
    <div class="ui-subtitle"></div>
    <div class="ui-meta">Tap the game window once to enable controls </div>
    <div class="ui-box">
      <div class="ui-box-title">CONTROLS</div>
      <div class="ui-box-body">
        <div><span>Move Paddle</span><b>← →</b> <span class="dim">or</span> <b>A / D</b></div>
        <div><span>Left Flipper</span><b>Z</b> &nbsp; <span>Right Flipper</span><b>X</b></div>
        <div><span>Start / Pause</span><b>P</b> &nbsp; <span>Shoot (Laser)</span><b>Space</b> <span class="dim">or</span> <b>K</b></div>
        <div><span>Powerups</span><b>L</b>=Lasers <b>M</b>=Multiball <b>E</b>=Extend <b>S</b>=Slow</div>
      </div>
    </div>
    <div class="ui-copy">©2025 by Mark Sandstorm.</div>
  </div>

</div>

<script>
/*
  Pink Pong MVP
  - Paddle controls: mouse/touch drag, keyboard A/D or Arrow keys (when canvas focused)
  - Flippers: Z (left), X (right); edge taps/clicks trigger flippers
  - Framerate-independent motion (dx/dy treated as pixels-per-60fps)
  - Ball speed clamp + dt clamp to stabilize physics
  - Flipper collision uses corrected segment direction + small cooldown to prevent jitter
*/

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const W = canvas.width, H = canvas.height;

/* ------------------ GAME STATE ------------------ */
let score = 0, lives = 3;
let balls = [];
let bricks = [];
let particles = [];

/* ------------------ OBJECTS ------------------ */
const paddle = { x: W/2 - 70, y: H - 120, w: 140, h: 22, speed: 7 };

// Flippers (vertical "legs" on left and right)
const FLIPPER_MARGIN = 6;
const FLIPPER_W = 18;
const FLIPPER_H = 118;
const FLIPPER_Y = H - 240;
const leftFlipper  = { x: FLIPPER_MARGIN, y: FLIPPER_Y, w: FLIPPER_W, h: FLIPPER_H, angle: 0, target: 0, maxAngle: -0.95 };
const rightFlipper = { x: W - FLIPPER_MARGIN - FLIPPER_W, y: FLIPPER_Y, w: FLIPPER_W, h: FLIPPER_H, angle: 0, target: 0, maxAngle:  0.95 };

const MAX_BALL_SPEED = 8.5;

  // --- SFX (WebAudio) ---
  // Browsers require a user gesture before audio can play.
  // We unlock/resume the AudioContext on first pointer/keyboard interaction.
  const SFX = (() => {
    let ctx = null;
    let master = null;
    let unlocked = false;
    let muted = false;

    function ensure() {
      if (ctx) return ctx;
      const AC = window.AudioContext || window.webkitAudioContext;
      if (!AC) return null;
      ctx = new AC();
      master = ctx.createGain();
      master.gain.value = 0.22;
      master.connect(ctx.destination);
      return ctx;
    }

    async function unlock() {
      const c = ensure();
      if (!c) return;
      if (c.state === "suspended") {
        try { await c.resume(); } catch (_) {}
      }
      unlocked = true;
    }

    function setMuted(v) {
      muted = !!v;
      if (master) master.gain.value = muted ? 0 : 0.22;
    }

    function beep(freq, dur = 0.06, type = "sine", vol = 0.22) {
      if (muted) return;
      const c = ensure();
      if (!c || !unlocked) return;
      const o = c.createOscillator();
      const g = c.createGain();
      o.type = type;
      o.frequency.value = freq;

      const t0 = c.currentTime;
      g.gain.setValueAtTime(0.0001, t0);
      g.gain.exponentialRampToValueAtTime(vol, t0 + 0.008);
      g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);

      o.connect(g);
      g.connect(master);
      o.start(t0);
      o.stop(t0 + dur + 0.02);
    }

    function noiseHit(dur = 0.05, vol = 0.18) {
      if (muted) return;
      const c = ensure();
      if (!c || !unlocked) return;

      const bufferSize = Math.floor(c.sampleRate * dur);
      const buffer = c.createBuffer(1, bufferSize, c.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i = 0; i < bufferSize; i++) data[i] = (Math.random() * 2 - 1) * (1 - i / bufferSize);

      const src = c.createBufferSource();
      src.buffer = buffer;

      const g = c.createGain();
      g.gain.value = vol;

      const filter = c.createBiquadFilter();
      filter.type = "highpass";
      filter.frequency.value = 900;

      src.connect(filter);
      filter.connect(g);
      g.connect(master);

      src.start();
      src.stop(c.currentTime + dur);
    }

    // Events
    return {
      unlock,
      setMuted,
      get muted() { return muted; },
      uiClick() { beep(780, 0.035, "square", 0.12); },
      brick() { noiseHit(0.045, 0.16); beep(560, 0.05, "triangle", 0.10); },
      paddle() { beep(420, 0.04, "sine", 0.10); },
      flipper() { beep(520, 0.03, "square", 0.10); },
      powerup() { beep(660, 0.06, "triangle", 0.12); beep(990, 0.05, "sine", 0.10); },
      loseLife() { beep(220, 0.10, "sawtooth", 0.14); },
      levelUp() { beep(740, 0.07, "triangle", 0.12); beep(1040, 0.08, "triangle", 0.12); }
    };
  })();

  // unlock audio on first gesture
  window.addEventListener("pointerdown", SFX.unlock, { once: true });
  window.addEventListener("keydown", SFX.unlock, { once: true });

     // clamp ball speed to stabilize physics
const EDGE_ZONE = 150;         // edge zone for flipper taps (px from left/right)
const FLIPPER_HIT_COOLDOWN = 0.08; // seconds
const FLIPPER_NUDGE = 3;       // pixels to push ball out after a flipper hit

/* ------------------ BRICKS ------------------ */
// (Level system now creates bricks. Original MVP layout preserved below for reference.)
// for(let r=0;r<4;r++){
//   for(let c=0;c<8;c++){
//     bricks.push({ x:40 + c*65, y:40 + r*26, w:60, h:20, hit:false });
//   }
// }

/* ------------------ BALL ------------------ */
function spawnBall(x,y,dx,dy){
  balls.push({ x, y, r:9, dx, dy, rot:0, flipperCooldown: 0 });
}
spawnBall(W/2, H/2, 3, -3);

/* ------------------ PARTICLES ------------------ */
function spawnParticles(x,y,color,count=12){
  for(let i=0;i<count;i++){
    const speed = 1 + Math.random()*2;
    const angle = Math.random()*Math.PI*2;
    particles.push({
      x, y,
      dx: Math.cos(angle)*speed,
      dy: Math.sin(angle)*speed - 1.2,
      life: 0.8 + Math.random()*0.4,
      age: 0,
      color
    });
  }
}

function brickBreakFX(x,y){
    if (typeof SFX !== 'undefined') SFX.brick();
  spawnParticles(x,y, '#ff1493', 18);
}

/* ------------------ DRAW HELPERS ------------------ */
function drawVinyl(b){
  ctx.save();
  ctx.translate(b.x,b.y);
  ctx.rotate(b.rot);
  ctx.fillStyle="#000";
  ctx.beginPath();ctx.arc(0,0,b.r,0,Math.PI*2);ctx.fill();
  ctx.fillStyle="#fff";
  ctx.beginPath();ctx.arc(0,0,3,0,Math.PI*2);ctx.fill();
  ctx.restore();
}

function drawDJBooth(){
  const px = paddle.x, py = paddle.y, pw = paddle.w, ph = paddle.h;

  // Controller body
  ctx.fillStyle = "#0a0a0a";
  ctx.fillRect(px, py, pw, ph);

  // Pink trim
  ctx.strokeStyle = "rgba(255,105,180,0.85)";
  ctx.lineWidth = 2;
  ctx.strokeRect(px+1, py+1, pw-2, ph-2);

  // Top deck + bottom fascia
  const deckH = Math.max(10, Math.round(ph*0.58));
  ctx.fillStyle = "rgba(255,105,180,0.13)";
  ctx.fillRect(px+4, py+4, pw-8, deckH-6);

  ctx.fillStyle = "rgba(255,105,180,0.07)";
  ctx.fillRect(px+4, py+deckH, pw-8, ph-deckH-4);

  // Jog wheels (left/right)
  const wheelR = Math.min(14, Math.round(ph*0.38));
  const wheelY = py + Math.round(deckH*0.55);
  const leftX  = px + Math.round(pw*0.22);
  const rightX = px + Math.round(pw*0.78);

  function jog(x,y){
    ctx.fillStyle = "#e6e6e6";
    ctx.beginPath(); ctx.arc(x,y,wheelR,0,Math.PI*2); ctx.fill();

    ctx.strokeStyle = "#111";
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.arc(x,y,wheelR-2,0,Math.PI*2); ctx.stroke();

    ctx.fillStyle = "#111";
    const hubR = Math.max(3, Math.round(wheelR*0.35));
    ctx.beginPath(); ctx.arc(x,y,hubR,0,Math.PI*2); ctx.fill();

    // tick mark
    ctx.strokeStyle = "rgba(255,105,180,0.9)";
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(x, y-wheelR+3); ctx.lineTo(x, y-wheelR+10); ctx.stroke();
  }
  jog(leftX, wheelY);
  jog(rightX, wheelY);

  // Center mixer section
  const mixW = Math.round(pw*0.30);
  const mixX = px + Math.round((pw-mixW)/2);
  const mixY = py + 6;
  const mixH = deckH - 12;

  ctx.fillStyle = "rgba(0,0,0,0.55)";
  ctx.fillRect(mixX, mixY, mixW, mixH);
  ctx.strokeStyle = "rgba(255,105,180,0.35)";
  ctx.lineWidth = 1;
  ctx.strokeRect(mixX+1, mixY+1, mixW-2, mixH-2);

  // EQ knobs
  const knobR = Math.max(2, Math.round(ph*0.10));
  const c1 = mixX + Math.round(mixW*0.32);
  const c2 = mixX + Math.round(mixW*0.68);
  const r1 = mixY + Math.round(mixH*0.28);
  const r2 = mixY + Math.round(mixH*0.50);
  const r3 = mixY + Math.round(mixH*0.72);

  function knob(x,y){
    ctx.fillStyle = "#e6e6e6";
    ctx.beginPath(); ctx.arc(x,y,knobR,0,Math.PI*2); ctx.fill();
    ctx.fillStyle = "#111";
    ctx.beginPath(); ctx.arc(x,y,Math.max(1, Math.round(knobR*0.35)),0,Math.PI*2); ctx.fill();
    ctx.strokeStyle = "rgba(255,105,180,0.75)";
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(x, y-knobR+2); ctx.lineTo(x, y-knobR+7); ctx.stroke();
  }
  knob(c1,r1); knob(c2,r1);
  knob(c1,r2); knob(c2,r2);
  knob(c1,r3); knob(c2,r3);

  // Crossfader
  const cfW = Math.round(mixW*0.86);
  const cfH = Math.max(3, Math.round(ph*0.14));
  const cfX = mixX + Math.round((mixW-cfW)/2);
  const cfY = mixY + mixH - Math.round(ph*0.18);

  ctx.fillStyle = "#111";
  ctx.fillRect(cfX, cfY, cfW, cfH);
  ctx.fillStyle = "#ffb6c1";
  const kx = cfX + Math.round(cfW*0.55);
  ctx.fillRect(kx-3, cfY-2, 6, cfH+4);

  // LED meter strip (centered)
  const ledCount = 10, ledW = 3, ledH = 6, ledGap = 4;
  const ledsTotalW = ledCount*ledW + (ledCount-1)*ledGap;
  const ledsX0 = mixX + Math.round((mixW - ledsTotalW)/2);
  const ledsY = py + deckH + Math.round((ph - deckH) * 0.38);

  for(let i=0;i<ledCount;i++){
    ctx.fillStyle = (i>6) ? "rgba(255,105,180,0.95)" : "rgba(255,182,193,0.95)";
    ctx.fillRect(ledsX0 + i*(ledW+ledGap), ledsY, ledW, ledH);
  }
}

/* Draw flipper: rotate around pivot near top */
function drawFlipper(f, left=true){
  ctx.save();
  const pivotX = f.x + f.w/2;
  const pivotY = f.y + 10;
  ctx.translate(pivotX, pivotY);
  ctx.rotate(f.angle);
  ctx.fillStyle = "#ff3f8a";
  ctx.fillRect(-f.w/2, 0, f.w, f.h);
  // dark line for edge detail
  ctx.fillStyle = "#000";
  ctx.fillRect(-f.w/2 + (left?f.w-4:0), f.h - 12, 4, 6);
  ctx.restore();
}

/* ------------------ GEOMETRY ------------------ */
function pointToSegmentDistance(px,py, x1,y1,x2,y2){
  const vx = x2 - x1, vy = y2 - y1;
  const wx = px - x1, wy = py - y1;
  const denom = (vx*vx + vy*vy) || 1;
  const c = (vx*wx + vy*wy) / denom;
  const t = Math.max(0, Math.min(1, c));
  const cx = x1 + vx * t, cy = y1 + vy * t;
  const dx = px - cx, dy = py - cy;
  return Math.sqrt(dx*dx + dy*dy);
}

/* ------------------ INPUT ------------------ */
const keys = { left: false, right: false, z:false, m:false };

function handleKeys(dt){
  const step = paddle.speed * 60 * dt;
  if(keys.left && !keys.right)  paddle.x -= step;
  if(keys.right && !keys.left)  paddle.x += step;

  leftFlipper.target  = keys.z ? leftFlipper.maxAngle : 0;
  rightFlipper.target = keys.x ? rightFlipper.maxAngle : 0;

  paddle.x = Math.max(0, Math.min(W - paddle.w, paddle.x));
}

canvas.addEventListener('keydown', (e) => {
  if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') e.preventDefault();
  if(e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') keys.left = true;
  if(e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') keys.right = true;
  if(e.key === 'z' || e.key === 'Z') keys.z = true;
  if(e.key === 'x' || e.key === 'X') keys.x = true;
});
canvas.addEventListener('keyup', (e) => {
  if(e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') keys.left = false;
  if(e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') keys.right = false;
  if(e.key === 'z' || e.key === 'Z') keys.z = false;
  if(e.key === 'x' || e.key === 'X') keys.x = false;
});

/* Mouse / touch -> paddle move + edge taps for flippers */
function canvasToLocal(evt){
  const rect = canvas.getBoundingClientRect();
  let clientX;
  if(evt.touches) clientX = evt.touches[0].clientX;
  else clientX = evt.clientX;
  return Math.max(0, Math.min(W, clientX - rect.left));
}

let isPointerDown = false;

canvas.addEventListener('mousedown', (e) => {
  isPointerDown = true;
  canvas.focus();
  const x = canvasToLocal(e);

  // move paddle immediately
  paddle.x = x - paddle.w / 2;
  paddle.x = Math.max(0, Math.min(W - paddle.w, paddle.x));

  // flipper tap only near edges
  if (x < EDGE_ZONE) triggerFlipperTap(leftFlipper);
  else if (x > W - EDGE_ZONE) triggerFlipperTap(rightFlipper);
});
window.addEventListener('mouseup', () => isPointerDown = false);
canvas.addEventListener('mouseleave', () => isPointerDown = false);

canvas.addEventListener('mousemove', (e) => {
  const down = isPointerDown || !!e.buttons;
  if(!down) return;
  const x = canvasToLocal(e);
  paddle.x = x - paddle.w/2;
  paddle.x = Math.max(0, Math.min(W - paddle.w, paddle.x));
});

canvas.addEventListener('touchstart', (e) => {
  e.preventDefault();
  canvas.focus();
  const x = canvasToLocal(e);
  paddle.x = x - paddle.w/2;
  paddle.x = Math.max(0, Math.min(W - paddle.w, paddle.x));

  if (x < EDGE_ZONE) triggerFlipperTap(leftFlipper);
  else if (x > W - EDGE_ZONE) triggerFlipperTap(rightFlipper);
}, { passive: false });

canvas.addEventListener('touchmove', (e) => {
  e.preventDefault();
  const x = canvasToLocal(e);
  paddle.x = x - paddle.w/2;
  paddle.x = Math.max(0, Math.min(W - paddle.w, paddle.x));
}, { passive: false });

canvas.addEventListener('touchend', (e) => {
  // no-op
}, { passive: false });

function triggerFlipperTap(f){
  f.target = f.maxAngle;
  setTimeout(()=>{ f.target = 0; }, 160);
}

canvas.addEventListener('click', () => canvas.focus());
canvas.style.touchAction = "none";

/* ------------------ PHYSICS ------------------ */
function handleFlipperCollision(b, f, dt){
  // cooldown: prevents repeated micro-collisions frame-to-frame
  if((b.flipperCooldown || 0) > 0) return;

  const pivotX = f.x + f.w/2;
  const pivotY = f.y + 10;
  const len = f.h;

  // corrected segment direction for your rotation/draw convention
  // (this tends to fix “left flipper moves but doesn't hit”)
  const sx = -Math.sin(f.angle) * len;
  const sy =  Math.cos(f.angle) * len;

  const x1 = pivotX, y1 = pivotY;
  const x2 = pivotX + sx, y2 = pivotY + sy;

  const dist = pointToSegmentDistance(b.x, b.y, x1, y1, x2, y2);
  const hitThreshold = b.r + 6;

  if(dist < hitThreshold){
    // nearest point on segment
    const vx = x2 - x1, vy = y2 - y1;
    const wx = b.x - x1, wy = b.y - y1;
    const denom = (vx*vx + vy*vy) || 1;
    const c = (vx*wx + vy*wy) / denom;
    const t = Math.max(0, Math.min(1, c));
    const cx = x1 + vx * t, cy = y1 + vy * t;

    // normal from segment to ball
    const nx = (b.x - cx), ny = (b.y - cy);
    const nlen = Math.sqrt(nx*nx + ny*ny) || 1;
    const nxn = nx / nlen, nyn = ny / nlen;

    // reflect velocity about normal
    const dot = b.dx * nxn + b.dy * nyn;
    b.dx = b.dx - 2 * dot * nxn;
    b.dy = b.dy - 2 * dot * nyn;

    // add a little kick
    b.dx += Math.sin(f.angle) * 1.1;
    b.dy -= Math.abs(Math.cos(f.angle)) * 1.1;

    // keep flipper hits punchy but not hyperspeed
    b.dx *= 0.98; // flipper damping
    b.dy *= 0.98; // flipper damping

    // IMPORTANT: flippers should send the ball upward, not downward.
    // Give a small upward "lift" and clamp so dy is always negative after a flipper hit.
    const LIFT = 1.4;
    b.dy = -Math.max(3.6, Math.abs(b.dy) + LIFT);

    // nudge out so next frame isn't still intersecting
    b.x = cx + nxn * (hitThreshold + FLIPPER_NUDGE);
    b.y = cy + nyn * (hitThreshold + FLIPPER_NUDGE);

    // cooldown + FX
    b.flipperCooldown = FLIPPER_HIT_COOLDOWN;
    spawnParticles(b.x, b.y, '#ff69b4', 6);
  }
}

/* ------------------ LOGIC ------------------ */
function update(dt){
  // Hard pause gate: stop all physics when paused
  if (window.Features?.state?.mode === "paused") return;

  // Let Features own gameover/levelclear timing and transitions
  if (window.Features?.state?.mode === "gameover" || window.Features?.state?.mode === "levelclear") {
    window.Features.update(dt);
    return;
  }

  handleKeys(dt);

  // flipper angles toward target
  const follow = 12;
  leftFlipper.angle  += (leftFlipper.target  - leftFlipper.angle)  * Math.min(1, follow * dt);
  rightFlipper.angle += (rightFlipper.target - rightFlipper.angle) * Math.min(1, follow * dt);

  for(let b of balls){
    // cooldown tick-down
    b.flipperCooldown = Math.max(0, (b.flipperCooldown || 0) - dt);

    // frame-rate independent motion (dx/dy treated as pixels-per-60fps)
    b.x += b.dx * 60 * dt;
    b.y += b.dy * 60 * dt;
    b.rot += 0.05 * (b.dx || 1) * 60 * dt;

    // wall bounce
    if(b.x - b.r < 0){ b.x = b.r; b.dx *= -1; }
    if(b.x + b.r > W){ b.x = W - b.r; b.dx *= -1; }
    if(b.y - b.r < 0){ b.y = b.r; b.dy *= -1; }

    // paddle collision
    if(b.y + b.r > paddle.y &&
       b.y - b.r < paddle.y + paddle.h &&
       b.x > paddle.x &&
       b.x < paddle.x + paddle.w){
      b.y = paddle.y - b.r;
      b.dy = -Math.abs(b.dy);
      if (typeof SFX !== 'undefined') SFX.paddle();
      const rel = (b.x - (paddle.x + paddle.w/2)) / (paddle.w/2);
      b.dx += rel * 1.2;
    }

    // flipper collisions
    handleFlipperCollision(b, leftFlipper, dt);
    handleFlipperCollision(b, rightFlipper, dt);

    // bricks
    for(let br of bricks){
      if(br.hit) continue;
      if(b.x + b.r > br.x && b.x - b.r < br.x + br.w &&
         b.y + b.r > br.y && b.y - b.r < br.y + br.h){

        // damage brick (supports hp)
        if(typeof br.hp === "number") br.hp -= 1;
        if(!br.hp || br.hp <= 0) br.hit = true;

        b.dy *= -1;
        score += 10;
        brickBreakFX(br.x + br.w/2, br.y + br.h/2);

        // powerup drop only when brick is actually destroyed
        if(br.hit) window.Features?.onBrickDestroyed?.(br);

        break;
      }
    }

    // bottom -> lose life & respawn (multiball-safe)
    if(b.y - b.r > H){
      const idx = balls.indexOf(b);
      window.Features?.onBallOut?.(idx >= 0 ? idx : 0);
      // balls array may have changed; stop processing balls this frame
      break;
    }

    // clamp ball speed to avoid runaway/tunneling
    const sp = Math.hypot(b.dx, b.dy);
    if (sp > MAX_BALL_SPEED) {
      const s = MAX_BALL_SPEED / sp;
      b.dx *= s;
      b.dy *= s;
    }

    // gentle minimum speed floor so the ball doesn't crawl forever
    const sp2 = Math.hypot(b.dx, b.dy);
    const MIN_BALL_SPEED = 4.5;
    if (sp2 > 0 && sp2 < MIN_BALL_SPEED) {
      const s2 = MIN_BALL_SPEED / sp2;
      b.dx *= s2;
      b.dy *= s2;
    }
  }

  // feature systems (powerups/lasers/level transitions)
  window.Features?.update?.(dt);

  // particles
  for(let p of particles){
    p.age += dt;
    p.x += p.dx * 60 * dt;
    p.y += p.dy * 60 * dt;
    p.dy += 60 * dt * 0.06;
  }
  particles = particles.filter(p => p.age < p.life);

  // safety clamp
  paddle.x = Math.max(0, Math.min(W - paddle.w, paddle.x));
}

/* ------------------ RENDER ------------------ */
function draw(){
  ctx.clearRect(0,0,W,H);

  // bricks (features: colors/shapes/hp)
  if (window.Features?.drawBricks) {
    window.Features.drawBricks(ctx);
  } else {
    for(let br of bricks){
      if(br.hit) continue;
      ctx.fillStyle = "#ff69b4";
      ctx.fillRect(br.x, br.y, br.w, br.h);
      ctx.fillStyle = "#111";
      ctx.fillRect(br.x+6, br.y+6, br.w-12, br.h-12);
    }
  }

  // balls
  for(let b of balls) drawVinyl(b);

  // paddle
  drawDJBooth();

  // flippers
  if (window.Features?.drawFlipperLeg) {
    window.Features.drawFlipperLeg(ctx, leftFlipper, true);
    window.Features.drawFlipperLeg(ctx, rightFlipper, false);
  } else {
    drawFlipper(leftFlipper, true);
    drawFlipper(rightFlipper, false);
  }

  // particles
  for(let p of particles){
    const t = 1 - (p.age / p.life);
    ctx.globalAlpha = Math.max(0, Math.min(1, t));
    ctx.fillStyle = p.color;
    ctx.beginPath();
    ctx.arc(p.x, p.y, 2.2, 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;
  }

  // feature overlays (powerups/lasers/pause/levelclear/gameover)
  window.Features?.draw?.(ctx);

  // HUD
  ctx.fillStyle = "#ddd";
  ctx.font = "14px Arial";
  ctx.fillText("Score: " + score, 12, H - 12);
  ctx.fillText("Lives: " + lives, W - 80, H - 12);
}


/* ================== FEATURES PACK ==================
   Lives restart, levels, powerups, pause, lasers, flipper art.
   (All in this index.html so you can stay in "one file" mode.)
===================================================== */
(function () {
  const CFG = {
    startLives: 3,
    powerupChance: 0.06,         // toned down
    powerupFallSpeed: 170,
    powerupDuration: 6,          // seconds (for laser/enlarge/slow)
    multiballCount: 1,           // less chaos
    maxBalls: 3,                 // hard cap
    laserSpeed: 760,
    levelClearDelay: 1.0,
    gameOverDelay: 0.9,
    minPowerupSpawnInterval: 3.0, // seconds
    maxSpawnedPowerups: 2
  };

  const Features = (window.Features = window.Features || {});
  const S = (Features.state = Features.state || {
    mode: "paused", // playing | paused | levelclear | gameover
    level: 1,
    spawnedPowerups: [],
    lastPowerupSpawnAt: 0,
    lasers: [],
    effects: { lasersUntil: 0, enlargeUntil: 0, slowUntil: 0 },
    basePaddleW: null,
    levelClearT: 0,
    gameOverT: 0
  });

  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const rand  = (a,b)=>Math.random()*(b-a)+a;
  const nowSec = ()=>performance.now()/1000;

  function rectsOverlap(ax, ay, aw, ah, bx, by, bw, bh) {
    return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
  }

  function roundRect(ctx, x, y, w, h, r) {
    r = Math.max(0, Math.min(r, Math.min(w, h) / 2));
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
  }

  function makeBricksForLevel(level) {
    const baseRows = 4;
    const baseCols = 8;

    const rows = baseRows + Math.min(level - 1, 6);
    const cols = baseCols + Math.floor((level - 1) / 2);

    const padX = 30;
    const padTop = 38;
    const gap = 6;

    const brickW = Math.floor((W - padX * 2) / cols);
    const brickH = 20 + Math.min(6, level);

    const palettes = [
      ["#ff69b4", "#ffb6c1"],
      ["#ff69b4", "#ff1493", "#ffc0cb", "#ff77aa"],
      ["#ff69b4", "#ff1493", "#ff00ff", "#ff77aa", "#ffd1f0"]
    ];
    const pal = palettes[Math.min(palettes.length - 1, Math.floor(level / 3))];

    const shapes = ["rect", "rounded", "triangle", "pill"];
    const maxShape = Math.min(shapes.length - 1, Math.floor(level / 2));

    const out = [];
    for (let r = 0; r < rows; r++) {
      for (let c = 0; c < cols; c++) {
        const x = padX + c * brickW;
        const y = padTop + r * (brickH + gap);
        const color = pal[(Math.random() * pal.length) | 0];
        const shape = shapes[(Math.random() * (maxShape + 1)) | 0];
        const hp = (level >= 4 && Math.random() < 0.22) ? 2 : 1;

        out.push({ x, y, w: brickW - 4, h: brickH, hit: false, hp, color, shape });
      }
    }
    return out;
  }

  Features.startLevel = function startLevel(level) {
    if (typeof SFX !== 'undefined' && level > 1) SFX.levelUp();
    // Ensure we exit interstitial states cleanly
    S.mode = "playing";
    S.levelClearT = 0;
    S.gameOverT = 0;
    S.level = level;
    bricks = makeBricksForLevel(level);

    S.spawnedPowerups = [];
    S.lasers = [];
    S.effects.lasersUntil = 0;
    S.effects.enlargeUntil = 0;
    S.effects.slowUntil = 0;

    if (S.basePaddleW == null) S.basePaddleW = paddle.w;

    balls = [];
    spawnBall(W / 2, H / 2, 3 * (Math.random() < 0.5 ? -1 : 1), -3);

    if (typeof spawnParticles === "function") spawnParticles(W / 2, H / 2, "#fff", 10);
  };

  Features.togglePause = function togglePause() {
    if (S.mode === "gameover") return;
    S.mode = (S.mode === "paused") ? "playing" : "paused";
    const btn = document.getElementById("pauseBtn");
    if (btn) {
      if (S.mode === "paused" && S.level === 1 && score === 0) btn.textContent = "Start";
      else btn.textContent = (S.mode === "paused") ? "Resume" : "Pause";
    }
  };

  Features.restartGame = function restartGame() {
    S.mode = "playing";
    S.level = 1;
    lives = CFG.startLives;
    score = 0;
    Features.startLevel(1);
  };

  // Multiball safe: only lose a life when the last ball falls out.
  Features.onBallOut = function onBallOut(ballIndex) {
    if (balls.length > 1) {
      balls.splice(ballIndex, 1);
      return;
    }
    lives -= 1;
      if (typeof SFX !== 'undefined') SFX.loseLife();
    if (lives <= 0) {
      S.mode = "gameover";
      S.gameOverT = CFG.gameOverDelay;
      return;
    }
    balls = [];
    spawnBall(W / 2, H / 2, 3, -3);
  };

  function maybeSpawnPowerup(x, y) {
    const t = nowSec();
    if (S.spawnedPowerups.length >= CFG.maxSpawnedPowerups) return;
    if (t - S.lastPowerupSpawnAt < CFG.minPowerupSpawnInterval) return;
    if (Math.random() > CFG.powerupChance) return;

    const types = ["multiball", "laser", "enlarge", "slow"];
    const type = types[(Math.random() * types.length) | 0];
    S.spawnedPowerups.push({ type, x, y, r: 10, vy: CFG.powerupFallSpeed });
    S.lastPowerupSpawnAt = t;
  }

  function applyPowerup(type) {
    const t = nowSec();

    if (type === "multiball") {
      if (!balls.length) return;
      if (balls.length >= CFG.maxBalls) return;
      const base = balls[0];
      for (let i = 0; i < CFG.multiballCount; i++) {
        balls.push({
          ...base,
          dx: base.dx + rand(-2.2, 2.2),
          dy: -Math.abs(base.dy) - rand(0, 1.2),
          flipperCooldown: 0
        });
      }
    }

    if (type === "laser") {
      S.effects.lasersUntil = Math.max(S.effects.lasersUntil, t + CFG.powerupDuration);
    }

    if (type === "enlarge") {
      if (S.basePaddleW == null) S.basePaddleW = paddle.w;
      S.effects.enlargeUntil = Math.max(S.effects.enlargeUntil, t + CFG.powerupDuration);
      paddle.w = clamp(S.basePaddleW * 1.5, 80, W * 0.65);
    }

    if (type === "slow") {
      S.effects.slowUntil = Math.max(S.effects.slowUntil, t + CFG.powerupDuration);
    }

    score += 25;
  }

  Features.getTimeScale = function getTimeScale() {
    return nowSec() < S.effects.slowUntil ? 0.85 : 1.0;
  };

  Features.shootLaser = function shootLaser() {
    if (nowSec() > S.effects.lasersUntil) return;
    const px = paddle.x + paddle.w / 2;
    const py = paddle.y - 8;
    S.lasers.push({ x: px - 10, y: py, w: 4, h: 12, vy: -CFG.laserSpeed });
    S.lasers.push({ x: px + 6,  y: py, w: 4, h: 12, vy: -CFG.laserSpeed });
  };

  function updateLasers(dt) {
    for (let i = S.lasers.length - 1; i >= 0; i--) {
      const L = S.lasers[i];
      L.y += L.vy * dt;

      for (const br of bricks) {
        if (br.hit) continue;
        if (rectsOverlap(L.x, L.y, L.w, L.h, br.x, br.y, br.w, br.h)) {
          if (typeof br.hp === "number") br.hp -= 1;
          if (!br.hp || br.hp <= 0) br.hit = true;

          score += 10;
          if (typeof brickBreakFX === "function") brickBreakFX(br.x + br.w/2, br.y + br.h/2);
          if (br.hit) maybeSpawnPowerup(br.x + br.w/2, br.y + br.h/2);

          S.lasers.splice(i, 1);
          break;
        }
      }

      if (L.y + L.h < -50) S.lasers.splice(i, 1);
    }
  }

  Features.onBrickDestroyed = function onBrickDestroyed(br) {
    maybeSpawnPowerup(br.x + br.w/2, br.y + br.h/2);
  };

  function allBricksCleared() {
    if (!bricks || !bricks.length) return false;
    for (const br of bricks) if (!br.hit) return false;
    return true;
  }

  Features.update = function update(dt) {
    if (S.mode === "paused") return;

    if (S.mode === "gameover") {
      S.gameOverT -= dt;
      if (S.gameOverT <= 0) Features.restartGame();
      return;
    }

    if (S.mode === "levelclear") {
      S.levelClearT -= dt;
      if (S.levelClearT <= 0) Features.startLevel(S.level + 1);
      return;
    }

    const t = nowSec();
    if (S.basePaddleW != null && t > S.effects.enlargeUntil) {
      paddle.w = S.basePaddleW;
      paddle.x = clamp(paddle.x, 0, W - paddle.w);
    }

    // falling powerups
    for (let i = S.spawnedPowerups.length - 1; i >= 0; i--) {
      const pu = S.spawnedPowerups[i];
      pu.y += pu.vy * dt;
      if (rectsOverlap(pu.x - pu.r, pu.y - pu.r, pu.r*2, pu.r*2, paddle.x, paddle.y, paddle.w, paddle.h)) {
        applyPowerup(pu.type);
        S.spawnedPowerups.splice(i, 1);
        continue;
      }
      if (pu.y > H + 60) S.spawnedPowerups.splice(i, 1);
    }

    updateLasers(dt);

    if (allBricksCleared()) {
      S.mode = "levelclear";
      S.levelClearT = CFG.levelClearDelay;
      score += 50 * S.level;
    }
  };

  Features.drawBricks = function drawBricks(ctx) {
    for (const br of bricks) {
      if (br.hit) continue;
      const color = br.color || "#ff69b4";
      const shape = br.shape || "rect";
      ctx.fillStyle = color;

      if (shape === "rounded") {
        roundRect(ctx, br.x, br.y, br.w, br.h, 7); ctx.fill();
        ctx.fillStyle = "#111";
        roundRect(ctx, br.x+6, br.y+6, br.w-12, br.h-12, 3); ctx.fill();
      } else if (shape === "pill") {
        roundRect(ctx, br.x, br.y, br.w, br.h, br.h/2); ctx.fill();
        ctx.fillStyle = "#111";
        roundRect(ctx, br.x+6, br.y+6, br.w-12, br.h-12, Math.max(2,(br.h-12)/2)); ctx.fill();
      } else if (shape === "triangle") {
        ctx.beginPath();
        ctx.moveTo(br.x + br.w/2, br.y);
        ctx.lineTo(br.x + br.w, br.y + br.h);
        ctx.lineTo(br.x, br.y + br.h);
        ctx.closePath(); ctx.fill();

        ctx.fillStyle = "#111";
        ctx.beginPath();
        ctx.moveTo(br.x + br.w/2, br.y+6);
        ctx.lineTo(br.x + br.w - 6, br.y + br.h - 6);
        ctx.lineTo(br.x+6, br.y + br.h - 6);
        ctx.closePath(); ctx.fill();
      } else {
        ctx.fillRect(br.x, br.y, br.w, br.h);
        ctx.fillStyle = "#111";
        ctx.fillRect(br.x+6, br.y+6, br.w-12, br.h-12);
      }

      if (typeof br.hp === "number" && br.hp > 1) {
        ctx.fillStyle = "#fff";
        ctx.font = "12px Arial";
        ctx.fillText(String(br.hp), br.x + 6, br.y + 15);
      }
    }
  };

  
  function drawMudflapTag(px, py, faceIn){
    // small tag hangs under the flipper pivot. faceIn: +1 for left, -1 for right (mirrors)
    ctx.save();
    ctx.translate(px, py + 10);
    ctx.scale(faceIn, 1);
    // tag plate
    ctx.fillStyle = "#111";
    ctx.fillRect(-14, 0, 28, 40);
    ctx.strokeStyle = "#ff69b4";
    ctx.lineWidth = 2;
    ctx.strokeRect(-14, 0, 28, 40);

    // simple girl silhouette
    ctx.fillStyle = "#000";
    ctx.beginPath(); ctx.arc(0, 10, 5, 0, Math.PI*2); ctx.fill();
    ctx.beginPath();
    ctx.moveTo(0, 15);
    ctx.lineTo(-7, 28);
    ctx.lineTo(0, 34);
    ctx.lineTo(7, 28);
    ctx.closePath();
    ctx.fill();
    ctx.fillRect(-6, 34, 4, 8);
    ctx.fillRect(2, 34, 4, 8);

    ctx.restore();
  }

Features.drawFlipperLeg = function drawFlipperLeg(ctx, f, isLeft) {
    // Pivot convention consistent with your flipper collision
    const pivotX = f.x + f.w / 2;
    const pivotY = f.y + 10;

    ctx.save();
    ctx.translate(pivotX, pivotY);
    ctx.rotate(f.angle);

    // Mirror ENTIRE leg+shoe so toe always points inward.
    const dir = isLeft ? 1 : -1;
    const SHOE_COLOR = \"#f8f8f8\"; // very light grey/near-white
    ctx.scale(dir, 1);

    // Tuned to your reference: slimmer leg, clean high-heel silhouette
    const Hh = f.h;
    const legW = Math.max(20, f.w * 2.0);     // thinner than before
    const ankleW = legW * 0.55;
    const calfBulge = legW * 0.06;

    const fill = "#ff69b4";   // pink leg
    const stroke = "#111";    // crisp outline like your sample

    // Helper: rounded-rect path
    function rr(x, y, w, h, r) {
      r = Math.max(0, Math.min(r, Math.min(w, h) / 2));
      ctx.beginPath();
      ctx.moveTo(x + r, y);
      ctx.arcTo(x + w, y, x + w, y + h, r);
      ctx.arcTo(x + w, y + h, x, y + h, r);
      ctx.arcTo(x, y + h, x, y, r);
      ctx.arcTo(x, y, x + w, y, r);
      ctx.closePath();
    }

    // --- LEG (single clean shape) ---
    ctx.fillStyle = fill;
    ctx.strokeStyle = stroke;
    ctx.lineWidth = 3;

    ctx.beginPath();
    // top left
    ctx.moveTo(-legW/2, 0);
    // outer contour with subtle calf bulge
    ctx.bezierCurveTo(
      -legW/2 - calfBulge, Hh*0.30,
      -legW/2 - calfBulge, Hh*0.58,
      -ankleW/2 - calfBulge*0.2, Hh*0.84
    );
    // down to ankle
    ctx.bezierCurveTo(
      -ankleW/2, Hh*0.93,
      -ankleW/2, Hh*0.985,
      -ankleW/2, Hh*1.00
    );
    // bottom across (ankle base)
    ctx.lineTo(ankleW/2, Hh*1.00);
    // inner contour (straighter)
    ctx.bezierCurveTo(
      ankleW/2, Hh*0.90,
      legW/2 - calfBulge*0.2, Hh*0.55,
      legW/2, Hh*0.18
    );
    // close top
    ctx.lineTo(legW/2, 0);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();

    // Small top nub like your reference
    rr(-legW*0.18, -6, legW*0.36, 12, 4);
    ctx.fill();
    ctx.stroke();

    // --- HIGH HEEL SHOE (single silhouette, not fragmented) ---
    const footY = Hh*1.00;

    // Shoe outline: upper + toe + heel in one continuous path
    ctx.beginPath();
    // start at back of ankle
    ctx.moveTo(-ankleW*0.45, footY - 10);

    // upper towards toe
    ctx.lineTo( ankleW*0.55, footY - 4);
    ctx.quadraticCurveTo( ankleW*0.95, footY + 4, ankleW*1.15, footY + 10); // pointed toe

    // sole back towards arch
    ctx.lineTo( ankleW*0.70, footY + 18);
    ctx.lineTo(-ankleW*0.55, footY + 12);

    // heel spike (stiletto)
    ctx.lineTo(-ankleW*0.25, footY + 34);
    ctx.lineTo(-ankleW*0.38, footY + 36);
    ctx.lineTo(-ankleW*0.42, footY + 12);

    ctx.closePath();
    ctx.fillStyle = SHOE_COLOR;
    ctx.fill();
    ctx.stroke();

    // Tiny darker sole line for readability
    ctx.globalAlpha = 0.20;
    ctx.strokeStyle = "#000";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(-ankleW*0.52, footY + 12);
    ctx.lineTo( ankleW*1.05, footY + 12);
    ctx.stroke();
    ctx.globalAlpha = 1;

    ctx.restore();
  };
// mudflap girl icon

  Features.draw = function draw(ctx) {
    // pickups
    for (const pu of S.spawnedPowerups) {
      ctx.fillStyle = ({ multiball:"#ffee66", laser:"#66ddff", enlarge:"#88ff88", slow:"#ff88ff" })[pu.type] || "#fff";
      ctx.beginPath();
      ctx.arc(pu.x, pu.y, pu.r, 0, Math.PI*2);
      ctx.fill();
      ctx.fillStyle = "#111";
      ctx.font = "10px Arial";
      ctx.fillText(pu.type[0].toUpperCase(), pu.x - 4, pu.y + 4);
    }

    // lasers
    for (const L of S.lasers) {
      ctx.fillStyle = "#66ddff";
      ctx.fillRect(L.x, L.y, L.w, L.h);
    }

    // overlays
    if (S.mode === "paused" || S.mode === "levelclear" || S.mode === "gameover") {
      ctx.fillStyle = "rgba(0,0,0,0.55)";
      ctx.fillRect(W/2 - 160, H/2 - 52, 320, 104);
      ctx.fillStyle = "#fff";
      ctx.font = "26px Arial";

      if (S.mode === "paused") ctx.fillText("PAUSED", W/2 - 62, H/2 - 6);
      if (S.mode === "levelclear") ctx.fillText(`LEVEL ${S.level} CLEAR`, W/2 - 106, H/2 - 6);
      if (S.mode === "gameover") ctx.fillText("GAME OVER", W/2 - 88, H/2 - 6);

      ctx.font = "14px Arial";
      if (S.mode === "paused") ctx.fillText("Press P or tap Pause to resume", W/2 - 108, H/2 + 24);
      if (S.mode === "levelclear") ctx.fillText("Next level incoming...", W/2 - 72, H/2 + 24);
      if (S.mode === "gameover") ctx.fillText("Restarting...", W/2 - 42, H/2 + 24);
    }
  };

  function ensurePauseButton() {
    let btn = document.getElementById("pauseBtn");
    if (!btn) {
      btn = document.createElement("button");
      btn.id = "pauseBtn";
      btn.textContent = (S.mode === "paused") ? "Start" : "Pause";
      btn.style.position = "absolute";
      btn.style.right = "12px";
      btn.style.bottom = "12px";
      btn.style.zIndex = 9999;
      btn.style.padding = "9px 12px";
      btn.style.background = "#ff69b4";
      btn.style.color = "#111";
      btn.style.border = "none";
      btn.style.borderRadius = "10px";
      btn.style.fontFamily = "Arial, sans-serif";
      btn.style.fontWeight = "700";
      btn.style.cursor = "pointer";
      document.body.appendChild(btn);
    }
    btn.onclick = () => Features.togglePause();
  }

  window.addEventListener("keydown", (e) => {
    const k = e.key.toLowerCase();
    if (k === "p") Features.togglePause();
    if (k === " " || k === "k") Features.shootLaser();
  });

  function boot(){
    ensurePauseButton();
    if (typeof ensureMuteButton === 'function') ensureMuteButton();
    // Initialize level 1 but stay paused until user starts
    Features.startLevel(1);
    isPaused = true;
    S.mode = "paused";
    const btn = document.getElementById("pauseBtn");
    if (btn) btn.textContent = "Start";
  }
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", boot);
  } else {
    boot();
  }
})();


/* ------------------ MAIN LOOP ------------------ */
let last = performance.now();
function tick(now){
  let dt = (now - last) / 1000;
  last = now;

  // clamp dt to prevent huge physics jumps (tab-switch, lag spike, etc.)
  dt = Math.min(dt, 1/30);

  // slow-time powerup scales simulation cleanly
  const timeScale = window.Features?.getTimeScale?.() ?? 1;
  dt *= timeScale;

  update(dt);
  draw();
  requestAnimationFrame(tick);
}
requestAnimationFrame(tick);
</script>
</body>
</html>
