<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>PinkPong — Browser Game</title>
  <style>
    :root{--bg:#ffeef6;--accent:#ff3f8a;--board:#fff}
    html,body{height:100%;margin:0;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;background:linear-gradient(180deg,var(--bg),#ffdff0);display:flex;align-items:center;justify-content:center}
    #game{box-shadow:0 10px 30px rgba(0,0,0,.15);border-radius:12px;background:var(--board);overflow:hidden}
    canvas{display:block;background:linear-gradient(180deg,#fff7fb,#fff1f7)}
    .hud{padding:12px 18px;display:flex;gap:12px;align-items:center;justify-content:space-between}
    .title{font-weight:700;color:#333}
    .score{font-weight:800;color:var(--accent);letter-spacing:2px}
    .controls{font-size:13px;color:#666}
    .footer{padding:10px 18px;text-align:center;font-size:13px;color:#555}
    button{background:var(--accent);color:#fff;border:none;padding:8px 12px;border-radius:8px;cursor:pointer}
  </style>
</head>
<body>
  <div id="game">
    <div class="hud">
      <div class="title">PinkPong</div>
      <div class="score" id="score">0 — 0</div>
      <div class="controls">Move: Mouse / W & S · Restart: Space</div>
    </div>
    <canvas id="c" width="900" height="500"></canvas>
    <div class="footer">Made with ♥ — Lightweight single-file demo</div>
  </div>

  <script>
    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;

    // Game state
    const paddle = {w:12,h:90, speed:8};
    const left = {x:30,y:(H-90)/2,score:0};
    const right = {x:W-30-12,y:(H-90)/2,score:0};
    const ball = {x:W/2,y:H/2,r:9,vx:5,vy:3};
    let running = true;

    const scoreEl = document.getElementById('score');

    function resetBall(direction=1){
      ball.x = W/2; ball.y = H/2;
      const speed = 4 + Math.random()*2;
      const ang = (Math.random()*Math.PI/4) - Math.PI/8; // small angle
      ball.vx = speed * Math.cos(ang) * direction;
      ball.vy = speed * Math.sin(ang);
    }

    // Input: mouse and keyboard
    let mouseY = H/2;
    canvas.addEventListener('mousemove', e=>{
      const rect = canvas.getBoundingClientRect();
      mouseY = (e.clientY - rect.top);
    });
    const keys = {};
    addEventListener('keydown', e=>{ keys[e.key.toLowerCase()]=true; if(e.code==='Space'){ left.score=0; right.score=0; resetBall(); } });
    addEventListener('keyup', e=>{ keys[e.key.toLowerCase()]=false; });

    function update(){
      // Left paddle: follow mouse primarily, keyboard fallback
      if(keys['w']) left.y -= paddle.speed;
      if(keys['s']) left.y += paddle.speed;
      // smooth follow mouse
      left.y += (mouseY - (left.y + paddle.h/2)) * 0.18;

      // Right paddle: simple AI — follow ball with some delay
      right.y += (ball.y - (right.y + paddle.h/2)) * 0.12;

      // Clamp paddles
      left.y = Math.max(6, Math.min(H - paddle.h - 6, left.y));
      right.y = Math.max(6, Math.min(H - paddle.h - 6, right.y));

      // Move ball
      ball.x += ball.vx; ball.y += ball.vy;
      // top/bottom collision
      if(ball.y - ball.r < 0){ ball.y = ball.r; ball.vy *= -1; }
      if(ball.y + ball.r > H){ ball.y = H - ball.r; ball.vy *= -1; }

      // paddle collisions
      if(ball.vx < 0 && ball.x - ball.r < left.x + paddle.w){
        if(ball.y > left.y && ball.y < left.y + paddle.h){
          ball.x = left.x + paddle.w + ball.r;
          ball.vx *= -1.08; // speed up slightly
          // add spin based on where it hit
          const hit = (ball.y - (left.y + paddle.h/2)) / (paddle.h/2);
          ball.vy += hit * 3;
        }
      }
      if(ball.vx > 0 && ball.x + ball.r > right.x){
        if(ball.y > right.y && ball.y < right.y + paddle.h){
          ball.x = right.x - ball.r;
          ball.vx *= -1.06;
          const hit = (ball.y - (right.y + paddle.h/2)) / (paddle.h/2);
          ball.vy += hit * 3;
        }
      }

      // Score
      if(ball.x + ball.r < 0){ right.score++; resetBall(1); }
      if(ball.x - ball.r > W){ left.score++; resetBall(-1); }

      scoreEl.textContent = `${left.score} — ${right.score}`;
    }

    function drawRoundedRect(x,y,w,h,r,fill){
      ctx.beginPath();
      ctx.moveTo(x+r,y);
      ctx.arcTo(x+w,y,x+w,y+h,r);
      ctx.arcTo(x+w,y+h,x,y+h,r);
      ctx.arcTo(x,y+h,x,y,r);
      ctx.arcTo(x,y,x+w,y,r);
      if(fill){ ctx.fill(); } else { ctx.stroke(); }
    }

    function draw(){
      // clear
      ctx.clearRect(0,0,W,H);

      // middle dashed line
      ctx.fillStyle = '#ffd9e9';
      for(let i=10;i<H;i+=28){ ctx.fillRect(W/2-3,i,6,16); }

      // paddles
      ctx.fillStyle = '#ff6ea1';
      drawRoundedRect(left.x,left.y,paddle.w,paddle.h,6,true);
      ctx.fillStyle = '#ff3f8a';
      drawRoundedRect(right.x,right.y,paddle.w,paddle.h,6,true);

      // ball
      const g = ctx.createRadialGradient(ball.x-3,ball.y-3,2,ball.x,ball.y,ball.r*2);
      g.addColorStop(0,'#fff'); g.addColorStop(1,'#ff2f77');
      ctx.fillStyle = g;
      ctx.beginPath(); ctx.arc(ball.x,ball.y,ball.r,0,Math.PI*2); ctx.fill();

      // small glow
      ctx.globalAlpha = 0.12;
      ctx.fillStyle = '#ff2f77'; ctx.beginPath(); ctx.arc(ball.x,ball.y,ball.r*4,0,Math.PI*2); ctx.fill();
      ctx.globalAlpha = 1;
    }

    // Main loop
    function loop(){ if(running){ update(); draw(); } requestAnimationFrame(loop); }

    // initialize
    resetBall(Math.random()>0.5?1:-1);
    loop();

    // Expose for debugging in console
    window.PinkPong = {left,right,ball,resetBall};
  </script>
</body>
</html>
