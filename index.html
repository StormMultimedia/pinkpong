<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Pura Power Pink Pong MVP</title>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
<style>
:root{--pink:#ff69b4;--hot:#ff1493;--bg:#111;--canvas-bg:#222}
body{margin:0;background:var(--bg);display:flex;justify-content:center;align-items:center;height:100vh}
.wrapper{position:relative}
canvas{background:var(--canvas-bg);border:2px solid var(--pink);border-radius:6px;outline:none}
.topbar{position:absolute;left:12px;top:10px;color:#ddd;font-size:14px;z-index:20}
.info{position:absolute;right:12px;top:10px;color:#ddd;font-size:13px;z-index:20;text-align:right}
</style>
</head>

<body>
<div class="wrapper">
  <div class="topbar">Pink Pong MVP</div>
  <div class="info">Controls: mouse / touch / ← → or A D (paddle) · Z (left flipper) · M (right flipper)</div>
  <canvas id="gameCanvas" width="600" height="400" tabindex="0"></canvas>
</div>

<script>
/*
  Pink Pong MVP
  - Paddle controls: mouse/touch drag, keyboard A/D or Arrow keys (when canvas focused)
  - Flippers: Z (left), M (right); edge taps/clicks trigger flippers
  - Framerate-independent motion (dx/dy treated as pixels-per-60fps)
  - Ball speed clamp + dt clamp to stabilize physics
  - Flipper collision uses corrected segment direction + small cooldown to prevent jitter
*/

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const W = canvas.width, H = canvas.height;

/* ------------------ GAME STATE ------------------ */
let score = 0, lives = 3;
let balls = [];
let bricks = [];
let particles = [];

/* ------------------ OBJECTS ------------------ */
const paddle = { x: 250, y: 360, w: 120, h: 22, speed: 6 };

// Flippers (vertical "legs" on left and right)
const leftFlipper  = { x: 14,  y: 170, w: 16, h: 80, angle: 0, target: 0, maxAngle: -0.9 };
const rightFlipper = { x: 570, y: 170, w: 16, h: 80, angle: 0, target: 0, maxAngle:  0.9 };

const MAX_BALL_SPEED = 12;     // clamp ball speed to stabilize physics
const EDGE_ZONE = 120;         // edge zone for flipper taps (px from left/right)
const FLIPPER_HIT_COOLDOWN = 0.08; // seconds
const FLIPPER_NUDGE = 3;       // pixels to push ball out after a flipper hit

/* ------------------ BRICKS ------------------ */
for(let r=0;r<4;r++){
  for(let c=0;c<8;c++){
    bricks.push({ x:40 + c*65, y:40 + r*26, w:60, h:20, hit:false });
  }
}

/* ------------------ BALL ------------------ */
function spawnBall(x,y,dx,dy){
  balls.push({ x, y, r:9, dx, dy, rot:0, flipperCooldown: 0 });
}
spawnBall(W/2, H/2, 3, -3);

/* ------------------ PARTICLES ------------------ */
function spawnParticles(x,y,color,count=12){
  for(let i=0;i<count;i++){
    const speed = 1 + Math.random()*2;
    const angle = Math.random()*Math.PI*2;
    particles.push({
      x, y,
      dx: Math.cos(angle)*speed,
      dy: Math.sin(angle)*speed - 1.2,
      life: 0.8 + Math.random()*0.4,
      age: 0,
      color
    });
  }
}

function brickBreakFX(x,y){
  spawnParticles(x,y, '#ff1493', 18);
}

/* ------------------ DRAW HELPERS ------------------ */
function drawVinyl(b){
  ctx.save();
  ctx.translate(b.x,b.y);
  ctx.rotate(b.rot);
  ctx.fillStyle="#000";
  ctx.beginPath();ctx.arc(0,0,b.r,0,Math.PI*2);ctx.fill();
  ctx.fillStyle="#fff";
  ctx.beginPath();ctx.arc(0,0,3,0,Math.PI*2);ctx.fill();
  ctx.restore();
}

function drawDJBooth(){
  ctx.fillStyle="#111";
  ctx.fillRect(paddle.x, paddle.y, paddle.w, paddle.h);
  // turntables
  ctx.fillStyle="#333";
  ctx.beginPath();ctx.arc(paddle.x+25,paddle.y+11,8,0,Math.PI*2);ctx.fill();
  ctx.beginPath();ctx.arc(paddle.x+paddle.w-25,paddle.y+11,8,0,Math.PI*2);ctx.fill();
  // mixer
  ctx.fillStyle="#ff69b4";
  ctx.fillRect(paddle.x + paddle.w/2 - 6, paddle.y + 4, 12, 14);
}

/* Draw flipper: rotate around pivot near top */
function drawFlipper(f, left=true){
  ctx.save();
  const pivotX = f.x + f.w/2;
  const pivotY = f.y + 10;
  ctx.translate(pivotX, pivotY);
  ctx.rotate(f.angle);
  ctx.fillStyle = "#ff3f8a";
  ctx.fillRect(-f.w/2, 0, f.w, f.h);
  // dark line for edge detail
  ctx.fillStyle = "#000";
  ctx.fillRect(-f.w/2 + (left?f.w-4:0), f.h - 12, 4, 6);
  ctx.restore();
}

/* ------------------ GEOMETRY ------------------ */
function pointToSegmentDistance(px,py, x1,y1,x2,y2){
  const vx = x2 - x1, vy = y2 - y1;
  const wx = px - x1, wy = py - y1;
  const denom = (vx*vx + vy*vy) || 1;
  const c = (vx*wx + vy*wy) / denom;
  const t = Math.max(0, Math.min(1, c));
  const cx = x1 + vx * t, cy = y1 + vy * t;
  const dx = px - cx, dy = py - cy;
  return Math.sqrt(dx*dx + dy*dy);
}

/* ------------------ INPUT ------------------ */
const keys = { left: false, right: false, z:false, m:false };

function handleKeys(dt){
  const step = paddle.speed * 60 * dt;
  if(keys.left && !keys.right)  paddle.x -= step;
  if(keys.right && !keys.left)  paddle.x += step;

  leftFlipper.target  = keys.z ? leftFlipper.maxAngle : 0;
  rightFlipper.target = keys.m ? rightFlipper.maxAngle : 0;

  paddle.x = Math.max(0, Math.min(W - paddle.w, paddle.x));
}

canvas.addEventListener('keydown', (e) => {
  if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') e.preventDefault();
  if(e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') keys.left = true;
  if(e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') keys.right = true;
  if(e.key === 'z' || e.key === 'Z') keys.z = true;
  if(e.key === 'm' || e.key === 'M') keys.m = true;
});
canvas.addEventListener('keyup', (e) => {
  if(e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') keys.left = false;
  if(e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') keys.right = false;
  if(e.key === 'z' || e.key === 'Z') keys.z = false;
  if(e.key === 'm' || e.key === 'M') keys.m = false;
});

/* Mouse / touch -> paddle move + edge taps for flippers */
function canvasToLocal(evt){
  const rect = canvas.getBoundingClientRect();
  let clientX;
  if(evt.touches) clientX = evt.touches[0].clientX;
  else clientX = evt.clientX;
  return Math.max(0, Math.min(W, clientX - rect.left));
}

let isPointerDown = false;

canvas.addEventListener('mousedown', (e) => {
  isPointerDown = true;
  canvas.focus();
  const x = canvasToLocal(e);

  // move paddle immediately
  paddle.x = x - paddle.w / 2;
  paddle.x = Math.max(0, Math.min(W - paddle.w, paddle.x));

  // flipper tap only near edges
  if (x < EDGE_ZONE) triggerFlipperTap(leftFlipper);
  else if (x > W - EDGE_ZONE) triggerFlipperTap(rightFlipper);
});
window.addEventListener('mouseup', () => isPointerDown = false);
canvas.addEventListener('mouseleave', () => isPointerDown = false);

canvas.addEventListener('mousemove', (e) => {
  const down = isPointerDown || !!e.buttons;
  if(!down) return;
  const x = canvasToLocal(e);
  paddle.x = x - paddle.w/2;
  paddle.x = Math.max(0, Math.min(W - paddle.w, paddle.x));
});

canvas.addEventListener('touchstart', (e) => {
  e.preventDefault();
  canvas.focus();
  const x = canvasToLocal(e);
  paddle.x = x - paddle.w/2;
  paddle.x = Math.max(0, Math.min(W - paddle.w, paddle.x));

  if (x < EDGE_ZONE) triggerFlipperTap(leftFlipper);
  else if (x > W - EDGE_ZONE) triggerFlipperTap(rightFlipper);
}, { passive: false });

canvas.addEventListener('touchmove', (e) => {
  e.preventDefault();
  const x = canvasToLocal(e);
  paddle.x = x - paddle.w/2;
  paddle.x = Math.max(0, Math.min(W - paddle.w, paddle.x));
}, { passive: false });

canvas.addEventListener('touchend', (e) => {
  // no-op
}, { passive: false });

function triggerFlipperTap(f){
  f.target = f.maxAngle;
  setTimeout(()=>{ f.target = 0; }, 160);
}

canvas.addEventListener('click', () => canvas.focus());
canvas.style.touchAction = "none";

/* ------------------ PHYSICS ------------------ */
function handleFlipperCollision(b, f, dt){
  // cooldown: prevents repeated micro-collisions frame-to-frame
  if((b.flipperCooldown || 0) > 0) return;

  const pivotX = f.x + f.w/2;
  const pivotY = f.y + 10;
  const len = f.h;

  // corrected segment direction for your rotation/draw convention
  // (this tends to fix “left flipper moves but doesn't hit”)
  const sx = -Math.sin(f.angle) * len;
  const sy =  Math.cos(f.angle) * len;

  const x1 = pivotX, y1 = pivotY;
  const x2 = pivotX + sx, y2 = pivotY + sy;

  const dist = pointToSegmentDistance(b.x, b.y, x1, y1, x2, y2);
  const hitThreshold = b.r + 6;

  if(dist < hitThreshold){
    // nearest point on segment
    const vx = x2 - x1, vy = y2 - y1;
    const wx = b.x - x1, wy = b.y - y1;
    const denom = (vx*vx + vy*vy) || 1;
    const c = (vx*wx + vy*wy) / denom;
    const t = Math.max(0, Math.min(1, c));
    const cx = x1 + vx * t, cy = y1 + vy * t;

    // normal from segment to ball
    const nx = (b.x - cx), ny = (b.y - cy);
    const nlen = Math.sqrt(nx*nx + ny*ny) || 1;
    const nxn = nx / nlen, nyn = ny / nlen;

    // reflect velocity about normal
    const dot = b.dx * nxn + b.dy * nyn;
    b.dx = b.dx - 2 * dot * nxn;
    b.dy = b.dy - 2 * dot * nyn;

    // add a little kick
    b.dx += Math.sin(f.angle) * 2;
    b.dy -= Math.abs(Math.cos(f.angle)) * 2;

    // nudge out so next frame isn't still intersecting
    b.x = cx + nxn * (hitThreshold + FLIPPER_NUDGE);
    b.y = cy + nyn * (hitThreshold + FLIPPER_NUDGE);

    // cooldown + FX
    b.flipperCooldown = FLIPPER_HIT_COOLDOWN;
    spawnParticles(b.x, b.y, '#ff69b4', 6);
  }
}

/* ------------------ LOGIC ------------------ */
function update(dt){
  handleKeys(dt);

  // flipper angles toward target
  const follow = 12;
  leftFlipper.angle  += (leftFlipper.target  - leftFlipper.angle)  * Math.min(1, follow * dt);
  rightFlipper.angle += (rightFlipper.target - rightFlipper.angle) * Math.min(1, follow * dt);

  for(let b of balls){
    // cooldown tick-down
    b.flipperCooldown = Math.max(0, (b.flipperCooldown || 0) - dt);

    // frame-rate independent motion (dx/dy treated as pixels-per-60fps)
    b.x += b.dx * 60 * dt;
    b.y += b.dy * 60 * dt;
    b.rot += 0.05 * (b.dx || 1) * 60 * dt;

    // wall bounce
    if(b.x - b.r < 0){ b.x = b.r; b.dx *= -1; }
    if(b.x + b.r > W){ b.x = W - b.r; b.dx *= -1; }
    if(b.y - b.r < 0){ b.y = b.r; b.dy *= -1; }

    // paddle collision
    if(b.y + b.r > paddle.y &&
       b.y - b.r < paddle.y + paddle.h &&
       b.x > paddle.x &&
       b.x < paddle.x + paddle.w){
      b.y = paddle.y - b.r;
      b.dy = -Math.abs(b.dy);
      const rel = (b.x - (paddle.x + paddle.w/2)) / (paddle.w/2);
      b.dx += rel * 2;
    }

    // flipper collisions
    handleFlipperCollision(b, leftFlipper, dt);
    handleFlipperCollision(b, rightFlipper, dt);

    // bricks
    for(let br of bricks){
      if(br.hit) continue;
      if(b.x + b.r > br.x && b.x - b.r < br.x + br.w &&
         b.y + b.r > br.y && b.y - b.r < br.y + br.h){
        br.hit = true;
        b.dy *= -1;
        score += 10;
        brickBreakFX(br.x + br.w/2, br.y + br.h/2);
      }
    }

    // bottom -> lose life & respawn
    if(b.y - b.r > H){
      lives -= 1;
      b.x = W/2; b.y = H/2; b.dx = 3; b.dy = -3;
      b.flipperCooldown = 0;
    }

    // clamp ball speed to avoid runaway/tunneling
    const sp = Math.hypot(b.dx, b.dy);
    if (sp > MAX_BALL_SPEED) {
      const s = MAX_BALL_SPEED / sp;
      b.dx *= s;
      b.dy *= s;
    }
  }

  // particles
  for(let p of particles){
    p.age += dt;
    p.x += p.dx * 60 * dt;
    p.y += p.dy * 60 * dt;
    p.dy += 60 * dt * 0.06;
  }
  particles = particles.filter(p => p.age < p.life);

  // safety clamp
  paddle.x = Math.max(0, Math.min(W - paddle.w, paddle.x));
}

/* ------------------ RENDER ------------------ */
function draw(){
  ctx.clearRect(0,0,W,H);

  // bricks
  for(let br of bricks){
    if(br.hit) continue;
    ctx.fillStyle = "#ff69b4";
    ctx.fillRect(br.x, br.y, br.w, br.h);
    ctx.fillStyle = "#111";
    ctx.fillRect(br.x+6, br.y+6, br.w-12, br.h-12);
  }

  // balls
  for(let b of balls) drawVinyl(b);

  // paddle
  drawDJBooth();

  // flippers
  drawFlipper(leftFlipper, true);
  drawFlipper(rightFlipper, false);

  // particles
  for(let p of particles){
    const t = 1 - (p.age / p.life);
    ctx.globalAlpha = Math.max(0, Math.min(1, t));
    ctx.fillStyle = p.color;
    ctx.beginPath();
    ctx.arc(p.x, p.y, 2.2, 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;
  }

  // HUD
  ctx.fillStyle = "#ddd";
  ctx.font = "14px Arial";
  ctx.fillText("Score: " + score, 12, H - 12);
  ctx.fillText("Lives: " + lives, W - 80, H - 12);
}

/* ------------------ MAIN LOOP ------------------ */
let last = performance.now();
function tick(now){
  let dt = (now - last) / 1000;
  last = now;

  // clamp dt to prevent huge physics jumps (tab-switch, lag spike, etc.)
  dt = Math.min(dt, 1/30);

  update(dt);
  draw();
  requestAnimationFrame(tick);
}
requestAnimationFrame(tick);
</script>
</body>
</html>
