<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Pura Power Pink Pong MVP</title>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
<style>
:root{--pink:#ff69b4;--hot:#ff1493;--bg:#111;--canvas-bg:#222}
body{margin:0;background:var(--bg);display:flex;justify-content:center;align-items:center;height:100vh}
.wrapper{position:relative}
canvas{background:var(--canvas-bg);border:2px solid var(--pink);border-radius:6px;outline:none}
.topbar{position:absolute;left:12px;top:10px;color:#ddd;font-size:14px;z-index:20}
.info{position:absolute;right:12px;top:10px;color:#ddd;font-size:13px;z-index:20;text-align:right}
</style>
</head>

<body>
<div class="wrapper">
  <div class="topbar">Pink Pong MVP</div>
  <div class="info">Controls: mouse / touch / ← → or A D (paddle) · Z (left flipper) · X (right flipper)</div>
  <canvas id="gameCanvas" width="720" height="720" tabindex="0"></canvas>
</div>

<script>
/*
  Pink Pong MVP
  - Paddle controls: mouse/touch drag, keyboard A/D or Arrow keys (when canvas focused)
  - Flippers: Z (left), X (right); edge taps/clicks trigger flippers
  - Framerate-independent motion (dx/dy treated as pixels-per-60fps)
  - Ball speed clamp + dt clamp to stabilize physics
  - Flipper collision uses corrected segment direction + small cooldown to prevent jitter
*/

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const W = canvas.width, H = canvas.height;

/* ------------------ GAME STATE ------------------ */
let score = 0, lives = 3;
let balls = [];
let bricks = [];
let particles = [];

/* ------------------ OBJECTS ------------------ */
const paddle = { x: W/2 - 70, y: H - 120, w: 140, h: 22, speed: 7 };

// Flippers (vertical "legs" on left and right)
const leftFlipper  = { x: 8, y: H - 230, w: 18, h: 110, angle: 0, target: 0, maxAngle: -0.95 };
const rightFlipper = { x: W - 8 - 18, y: H - 230, w: 18, h: 110, angle: 0, target: 0, maxAngle:  0.95 };

const MAX_BALL_SPEED = 8.5;     // clamp ball speed to stabilize physics
const EDGE_ZONE = 150;         // edge zone for flipper taps (px from left/right)
const FLIPPER_HIT_COOLDOWN = 0.08; // seconds
const FLIPPER_NUDGE = 3;       // pixels to push ball out after a flipper hit

/* ------------------ BRICKS ------------------ */
// (Level system now creates bricks. Original MVP layout preserved below for reference.)
// for(let r=0;r<4;r++){
//   for(let c=0;c<8;c++){
//     bricks.push({ x:40 + c*65, y:40 + r*26, w:60, h:20, hit:false });
//   }
// }

/* ------------------ BALL ------------------ */
function spawnBall(x,y,dx,dy){
  balls.push({ x, y, r:9, dx, dy, rot:0, flipperCooldown: 0 });
}
spawnBall(W/2, H/2, 3, -3);

/* ------------------ PARTICLES ------------------ */
function spawnParticles(x,y,color,count=12){
  for(let i=0;i<count;i++){
    const speed = 1 + Math.random()*2;
    const angle = Math.random()*Math.PI*2;
    particles.push({
      x, y,
      dx: Math.cos(angle)*speed,
      dy: Math.sin(angle)*speed - 1.2,
      life: 0.8 + Math.random()*0.4,
      age: 0,
      color
    });
  }
}

function brickBreakFX(x,y){
  spawnParticles(x,y, '#ff1493', 18);
}

/* ------------------ DRAW HELPERS ------------------ */
function drawVinyl(b){
  ctx.save();
  ctx.translate(b.x,b.y);
  ctx.rotate(b.rot);
  ctx.fillStyle="#000";
  ctx.beginPath();ctx.arc(0,0,b.r,0,Math.PI*2);ctx.fill();
  ctx.fillStyle="#fff";
  ctx.beginPath();ctx.arc(0,0,3,0,Math.PI*2);ctx.fill();
  ctx.restore();
}

function drawDJBooth(){
  ctx.fillStyle="#111";
  ctx.fillRect(paddle.x, paddle.y, paddle.w, paddle.h);
  // turntables
  ctx.fillStyle="#333";
  ctx.beginPath();ctx.arc(paddle.x+25,paddle.y+11,8,0,Math.PI*2);ctx.fill();
  ctx.beginPath();ctx.arc(paddle.x+paddle.w-25,paddle.y+11,8,0,Math.PI*2);ctx.fill();
  // mixer
  ctx.fillStyle="#ff69b4";
  ctx.fillRect(paddle.x + paddle.w/2 - 6, paddle.y + 4, 12, 14);
}

/* Draw flipper: rotate around pivot near top */
function drawFlipper(f, left=true){
  ctx.save();
  const pivotX = f.x + f.w/2;
  const pivotY = f.y + 10;
  ctx.translate(pivotX, pivotY);
  ctx.rotate(f.angle);
  ctx.fillStyle = "#ff3f8a";
  ctx.fillRect(-f.w/2, 0, f.w, f.h);
  // dark line for edge detail
  ctx.fillStyle = "#000";
  ctx.fillRect(-f.w/2 + (left?f.w-4:0), f.h - 12, 4, 6);
  ctx.restore();
}

/* ------------------ GEOMETRY ------------------ */
function pointToSegmentDistance(px,py, x1,y1,x2,y2){
  const vx = x2 - x1, vy = y2 - y1;
  const wx = px - x1, wy = py - y1;
  const denom = (vx*vx + vy*vy) || 1;
  const c = (vx*wx + vy*wy) / denom;
  const t = Math.max(0, Math.min(1, c));
  const cx = x1 + vx * t, cy = y1 + vy * t;
  const dx = px - cx, dy = py - cy;
  return Math.sqrt(dx*dx + dy*dy);
}

/* ------------------ INPUT ------------------ */
const keys = { left: false, right: false, z:false, m:false };

function handleKeys(dt){
  const step = paddle.speed * 60 * dt;
  if(keys.left && !keys.right)  paddle.x -= step;
  if(keys.right && !keys.left)  paddle.x += step;

  leftFlipper.target  = keys.z ? leftFlipper.maxAngle : 0;
  rightFlipper.target = keys.x ? rightFlipper.maxAngle : 0;

  paddle.x = Math.max(0, Math.min(W - paddle.w, paddle.x));
}

canvas.addEventListener('keydown', (e) => {
  if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') e.preventDefault();
  if(e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') keys.left = true;
  if(e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') keys.right = true;
  if(e.key === 'z' || e.key === 'Z') keys.z = true;
  if(e.key === 'x' || e.key === 'X') keys.x = true;
});
canvas.addEventListener('keyup', (e) => {
  if(e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') keys.left = false;
  if(e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') keys.right = false;
  if(e.key === 'z' || e.key === 'Z') keys.z = false;
  if(e.key === 'x' || e.key === 'X') keys.x = false;
});

/* Mouse / touch -> paddle move + edge taps for flippers */
function canvasToLocal(evt){
  const rect = canvas.getBoundingClientRect();
  let clientX;
  if(evt.touches) clientX = evt.touches[0].clientX;
  else clientX = evt.clientX;
  return Math.max(0, Math.min(W, clientX - rect.left));
}

let isPointerDown = false;

canvas.addEventListener('mousedown', (e) => {
  isPointerDown = true;
  canvas.focus();
  const x = canvasToLocal(e);

  // move paddle immediately
  paddle.x = x - paddle.w / 2;
  paddle.x = Math.max(0, Math.min(W - paddle.w, paddle.x));

  // flipper tap only near edges
  if (x < EDGE_ZONE) triggerFlipperTap(leftFlipper);
  else if (x > W - EDGE_ZONE) triggerFlipperTap(rightFlipper);
});
window.addEventListener('mouseup', () => isPointerDown = false);
canvas.addEventListener('mouseleave', () => isPointerDown = false);

canvas.addEventListener('mousemove', (e) => {
  const down = isPointerDown || !!e.buttons;
  if(!down) return;
  const x = canvasToLocal(e);
  paddle.x = x - paddle.w/2;
  paddle.x = Math.max(0, Math.min(W - paddle.w, paddle.x));
});

canvas.addEventListener('touchstart', (e) => {
  e.preventDefault();
  canvas.focus();
  const x = canvasToLocal(e);
  paddle.x = x - paddle.w/2;
  paddle.x = Math.max(0, Math.min(W - paddle.w, paddle.x));

  if (x < EDGE_ZONE) triggerFlipperTap(leftFlipper);
  else if (x > W - EDGE_ZONE) triggerFlipperTap(rightFlipper);
}, { passive: false });

canvas.addEventListener('touchmove', (e) => {
  e.preventDefault();
  const x = canvasToLocal(e);
  paddle.x = x - paddle.w/2;
  paddle.x = Math.max(0, Math.min(W - paddle.w, paddle.x));
}, { passive: false });

canvas.addEventListener('touchend', (e) => {
  // no-op
}, { passive: false });

function triggerFlipperTap(f){
  f.target = f.maxAngle;
  setTimeout(()=>{ f.target = 0; }, 160);
}

canvas.addEventListener('click', () => canvas.focus());
canvas.style.touchAction = "none";

/* ------------------ PHYSICS ------------------ */
function handleFlipperCollision(b, f, dt){
  // cooldown: prevents repeated micro-collisions frame-to-frame
  if((b.flipperCooldown || 0) > 0) return;

  const pivotX = f.x + f.w/2;
  const pivotY = f.y + 10;
  const len = f.h;

  // corrected segment direction for your rotation/draw convention
  // (this tends to fix “left flipper moves but doesn't hit”)
  const sx = -Math.sin(f.angle) * len;
  const sy =  Math.cos(f.angle) * len;

  const x1 = pivotX, y1 = pivotY;
  const x2 = pivotX + sx, y2 = pivotY + sy;

  const dist = pointToSegmentDistance(b.x, b.y, x1, y1, x2, y2);
  const hitThreshold = b.r + 6;

  if(dist < hitThreshold){
    // nearest point on segment
    const vx = x2 - x1, vy = y2 - y1;
    const wx = b.x - x1, wy = b.y - y1;
    const denom = (vx*vx + vy*vy) || 1;
    const c = (vx*wx + vy*wy) / denom;
    const t = Math.max(0, Math.min(1, c));
    const cx = x1 + vx * t, cy = y1 + vy * t;

    // normal from segment to ball
    const nx = (b.x - cx), ny = (b.y - cy);
    const nlen = Math.sqrt(nx*nx + ny*ny) || 1;
    const nxn = nx / nlen, nyn = ny / nlen;

    // reflect velocity about normal
    const dot = b.dx * nxn + b.dy * nyn;
    b.dx = b.dx - 2 * dot * nxn;
    b.dy = b.dy - 2 * dot * nyn;

    // add a little kick
    b.dx += Math.sin(f.angle) * 1.1;
    b.dy -= Math.abs(Math.cos(f.angle)) * 1.1;

    // keep flipper hits punchy but not hyperspeed
    b.dx *= 0.98; // flipper damping
    b.dy *= 0.98; // flipper damping

    // nudge out so next frame isn't still intersecting
    b.x = cx + nxn * (hitThreshold + FLIPPER_NUDGE);
    b.y = cy + nyn * (hitThreshold + FLIPPER_NUDGE);

    // cooldown + FX
    b.flipperCooldown = FLIPPER_HIT_COOLDOWN;
    spawnParticles(b.x, b.y, '#ff69b4', 6);
  }
}

/* ------------------ LOGIC ------------------ */
function update(dt){
  // Hard pause gate: stop all physics when paused
  if (window.Features?.state?.mode === "paused") return;

  // Let Features own gameover/levelclear timing and transitions
  if (window.Features?.state?.mode === "gameover" || window.Features?.state?.mode === "levelclear") {
    window.Features.update(dt);
    return;
  }

  handleKeys(dt);

  // flipper angles toward target
  const follow = 12;
  leftFlipper.angle  += (leftFlipper.target  - leftFlipper.angle)  * Math.min(1, follow * dt);
  rightFlipper.angle += (rightFlipper.target - rightFlipper.angle) * Math.min(1, follow * dt);

  for(let b of balls){
    // cooldown tick-down
    b.flipperCooldown = Math.max(0, (b.flipperCooldown || 0) - dt);

    // frame-rate independent motion (dx/dy treated as pixels-per-60fps)
    b.x += b.dx * 60 * dt;
    b.y += b.dy * 60 * dt;
    b.rot += 0.05 * (b.dx || 1) * 60 * dt;

    // wall bounce
    if(b.x - b.r < 0){ b.x = b.r; b.dx *= -1; }
    if(b.x + b.r > W){ b.x = W - b.r; b.dx *= -1; }
    if(b.y - b.r < 0){ b.y = b.r; b.dy *= -1; }

    // paddle collision
    if(b.y + b.r > paddle.y &&
       b.y - b.r < paddle.y + paddle.h &&
       b.x > paddle.x &&
       b.x < paddle.x + paddle.w){
      b.y = paddle.y - b.r;
      b.dy = -Math.abs(b.dy);
      const rel = (b.x - (paddle.x + paddle.w/2)) / (paddle.w/2);
      b.dx += rel * 1.2;
    }

    // flipper collisions
    handleFlipperCollision(b, leftFlipper, dt);
    handleFlipperCollision(b, rightFlipper, dt);

    // bricks
    for(let br of bricks){
      if(br.hit) continue;
      if(b.x + b.r > br.x && b.x - b.r < br.x + br.w &&
         b.y + b.r > br.y && b.y - b.r < br.y + br.h){

        // damage brick (supports hp)
        if(typeof br.hp === "number") br.hp -= 1;
        if(!br.hp || br.hp <= 0) br.hit = true;

        b.dy *= -1;
        score += 10;
        brickBreakFX(br.x + br.w/2, br.y + br.h/2);

        // powerup drop only when brick is actually destroyed
        if(br.hit) window.Features?.onBrickDestroyed?.(br);

        break;
      }
    }

    // bottom -> lose life & respawn (multiball-safe)
    if(b.y - b.r > H){
      const idx = balls.indexOf(b);
      window.Features?.onBallOut?.(idx >= 0 ? idx : 0);
      // balls array may have changed; stop processing balls this frame
      break;
    }

    // clamp ball speed to avoid runaway/tunneling
    const sp = Math.hypot(b.dx, b.dy);
    if (sp > MAX_BALL_SPEED) {
      const s = MAX_BALL_SPEED / sp;
      b.dx *= s;
      b.dy *= s;
    }

    // gentle minimum speed floor so the ball doesn't crawl forever
    const sp2 = Math.hypot(b.dx, b.dy);
    const MIN_BALL_SPEED = 4.5;
    if (sp2 > 0 && sp2 < MIN_BALL_SPEED) {
      const s2 = MIN_BALL_SPEED / sp2;
      b.dx *= s2;
      b.dy *= s2;
    }
  }

  // feature systems (powerups/lasers/level transitions)
  window.Features?.update?.(dt);

  // particles
  for(let p of particles){
    p.age += dt;
    p.x += p.dx * 60 * dt;
    p.y += p.dy * 60 * dt;
    p.dy += 60 * dt * 0.06;
  }
  particles = particles.filter(p => p.age < p.life);

  // safety clamp
  paddle.x = Math.max(0, Math.min(W - paddle.w, paddle.x));
}

/* ------------------ RENDER ------------------ */
function draw(){
  ctx.clearRect(0,0,W,H);

  // bricks (features: colors/shapes/hp)
  if (window.Features?.drawBricks) {
    window.Features.drawBricks(ctx);
  } else {
    for(let br of bricks){
      if(br.hit) continue;
      ctx.fillStyle = "#ff69b4";
      ctx.fillRect(br.x, br.y, br.w, br.h);
      ctx.fillStyle = "#111";
      ctx.fillRect(br.x+6, br.y+6, br.w-12, br.h-12);
    }
  }

  // balls
  for(let b of balls) drawVinyl(b);

  // paddle
  drawDJBooth();

  // flippers
  if (window.Features?.drawFlipperLeg) {
    window.Features.drawFlipperLeg(ctx, leftFlipper, true);
    window.Features.drawFlipperLeg(ctx, rightFlipper, false);
  } else {
    drawFlipper(leftFlipper, true);
    drawFlipper(rightFlipper, false);
  }

  // particles
  for(let p of particles){
    const t = 1 - (p.age / p.life);
    ctx.globalAlpha = Math.max(0, Math.min(1, t));
    ctx.fillStyle = p.color;
    ctx.beginPath();
    ctx.arc(p.x, p.y, 2.2, 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;
  }

  // feature overlays (powerups/lasers/pause/levelclear/gameover)
  window.Features?.draw?.(ctx);

  // HUD
  ctx.fillStyle = "#ddd";
  ctx.font = "14px Arial";
  ctx.fillText("Score: " + score, 12, H - 12);
  ctx.fillText("Lives: " + lives, W - 80, H - 12);
}


/* ================== FEATURES PACK ==================
   Lives restart, levels, powerups, pause, lasers, flipper art.
   (All in this index.html so you can stay in "one file" mode.)
===================================================== */
(function () {
  const CFG = {
    startLives: 3,
    powerupChance: 0.06,         // toned down
    powerupFallSpeed: 170,
    powerupDuration: 6,          // seconds (for laser/enlarge/slow)
    multiballCount: 1,           // less chaos
    maxBalls: 3,                 // hard cap
    laserSpeed: 760,
    levelClearDelay: 1.0,
    gameOverDelay: 0.9,
    minPowerupSpawnInterval: 3.0, // seconds
    maxSpawnedPowerups: 2
  };

  const Features = (window.Features = window.Features || {});
  const S = (Features.state = Features.state || {
    mode: "playing", // playing | paused | levelclear | gameover
    level: 1,
    spawnedPowerups: [],
    lastPowerupSpawnAt: 0,
    lasers: [],
    effects: { lasersUntil: 0, enlargeUntil: 0, slowUntil: 0 },
    basePaddleW: null,
    levelClearT: 0,
    gameOverT: 0
  });

  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const rand  = (a,b)=>Math.random()*(b-a)+a;
  const nowSec = ()=>performance.now()/1000;

  function rectsOverlap(ax, ay, aw, ah, bx, by, bw, bh) {
    return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
  }

  function roundRect(ctx, x, y, w, h, r) {
    r = Math.max(0, Math.min(r, Math.min(w, h) / 2));
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
  }

  function makeBricksForLevel(level) {
    const baseRows = 4;
    const baseCols = 8;

    const rows = baseRows + Math.min(level - 1, 6);
    const cols = baseCols + Math.floor((level - 1) / 2);

    const padX = 30;
    const padTop = 38;
    const gap = 6;

    const brickW = Math.floor((W - padX * 2) / cols);
    const brickH = 20 + Math.min(6, level);

    const palettes = [
      ["#ff69b4", "#ffb6c1"],
      ["#ff69b4", "#ff1493", "#ffc0cb", "#ff77aa"],
      ["#ff69b4", "#ff1493", "#ff00ff", "#ff77aa", "#ffd1f0"]
    ];
    const pal = palettes[Math.min(palettes.length - 1, Math.floor(level / 3))];

    const shapes = ["rect", "rounded", "triangle", "pill"];
    const maxShape = Math.min(shapes.length - 1, Math.floor(level / 2));

    const out = [];
    for (let r = 0; r < rows; r++) {
      for (let c = 0; c < cols; c++) {
        const x = padX + c * brickW;
        const y = padTop + r * (brickH + gap);
        const color = pal[(Math.random() * pal.length) | 0];
        const shape = shapes[(Math.random() * (maxShape + 1)) | 0];
        const hp = (level >= 4 && Math.random() < 0.22) ? 2 : 1;

        out.push({ x, y, w: brickW - 4, h: brickH, hit: false, hp, color, shape });
      }
    }
    return out;
  }

  Features.startLevel = function startLevel(level) {
    // Ensure we exit interstitial states cleanly
    S.mode = "playing";
    S.levelClearT = 0;
    S.gameOverT = 0;
    S.level = level;
    bricks = makeBricksForLevel(level);

    S.spawnedPowerups = [];
    S.lasers = [];
    S.effects.lasersUntil = 0;
    S.effects.enlargeUntil = 0;
    S.effects.slowUntil = 0;

    if (S.basePaddleW == null) S.basePaddleW = paddle.w;

    balls = [];
    spawnBall(W / 2, H / 2, 3 * (Math.random() < 0.5 ? -1 : 1), -3);

    if (typeof spawnParticles === "function") spawnParticles(W / 2, H / 2, "#fff", 10);
  };

  Features.togglePause = function togglePause() {
    if (S.mode === "gameover") return;
    S.mode = (S.mode === "paused") ? "playing" : "paused";
    const btn = document.getElementById("pauseBtn");
    if (btn) btn.textContent = (S.mode === "paused") ? "Resume" : "Pause";
  };

  Features.restartGame = function restartGame() {
    S.mode = "playing";
    S.level = 1;
    lives = CFG.startLives;
    score = 0;
    Features.startLevel(1);
  };

  // Multiball safe: only lose a life when the last ball falls out.
  Features.onBallOut = function onBallOut(ballIndex) {
    if (balls.length > 1) {
      balls.splice(ballIndex, 1);
      return;
    }
    lives -= 1;
    if (lives <= 0) {
      S.mode = "gameover";
      S.gameOverT = CFG.gameOverDelay;
      return;
    }
    balls = [];
    spawnBall(W / 2, H / 2, 3, -3);
  };

  function maybeSpawnPowerup(x, y) {
    const t = nowSec();
    if (S.spawnedPowerups.length >= CFG.maxSpawnedPowerups) return;
    if (t - S.lastPowerupSpawnAt < CFG.minPowerupSpawnInterval) return;
    if (Math.random() > CFG.powerupChance) return;

    const types = ["multiball", "laser", "enlarge", "slow"];
    const type = types[(Math.random() * types.length) | 0];
    S.spawnedPowerups.push({ type, x, y, r: 10, vy: CFG.powerupFallSpeed });
    S.lastPowerupSpawnAt = t;
  }

  function applyPowerup(type) {
    const t = nowSec();

    if (type === "multiball") {
      if (!balls.length) return;
      if (balls.length >= CFG.maxBalls) return;
      const base = balls[0];
      for (let i = 0; i < CFG.multiballCount; i++) {
        balls.push({
          ...base,
          dx: base.dx + rand(-2.2, 2.2),
          dy: -Math.abs(base.dy) - rand(0, 1.2),
          flipperCooldown: 0
        });
      }
    }

    if (type === "laser") {
      S.effects.lasersUntil = Math.max(S.effects.lasersUntil, t + CFG.powerupDuration);
    }

    if (type === "enlarge") {
      if (S.basePaddleW == null) S.basePaddleW = paddle.w;
      S.effects.enlargeUntil = Math.max(S.effects.enlargeUntil, t + CFG.powerupDuration);
      paddle.w = clamp(S.basePaddleW * 1.5, 80, W * 0.65);
    }

    if (type === "slow") {
      S.effects.slowUntil = Math.max(S.effects.slowUntil, t + CFG.powerupDuration);
    }

    score += 25;
  }

  Features.getTimeScale = function getTimeScale() {
    return nowSec() < S.effects.slowUntil ? 0.85 : 1.0;
  };

  Features.shootLaser = function shootLaser() {
    if (nowSec() > S.effects.lasersUntil) return;
    const px = paddle.x + paddle.w / 2;
    const py = paddle.y - 8;
    S.lasers.push({ x: px - 10, y: py, w: 4, h: 12, vy: -CFG.laserSpeed });
    S.lasers.push({ x: px + 6,  y: py, w: 4, h: 12, vy: -CFG.laserSpeed });
  };

  function updateLasers(dt) {
    for (let i = S.lasers.length - 1; i >= 0; i--) {
      const L = S.lasers[i];
      L.y += L.vy * dt;

      for (const br of bricks) {
        if (br.hit) continue;
        if (rectsOverlap(L.x, L.y, L.w, L.h, br.x, br.y, br.w, br.h)) {
          if (typeof br.hp === "number") br.hp -= 1;
          if (!br.hp || br.hp <= 0) br.hit = true;

          score += 10;
          if (typeof brickBreakFX === "function") brickBreakFX(br.x + br.w/2, br.y + br.h/2);
          if (br.hit) maybeSpawnPowerup(br.x + br.w/2, br.y + br.h/2);

          S.lasers.splice(i, 1);
          break;
        }
      }

      if (L.y + L.h < -50) S.lasers.splice(i, 1);
    }
  }

  Features.onBrickDestroyed = function onBrickDestroyed(br) {
    maybeSpawnPowerup(br.x + br.w/2, br.y + br.h/2);
  };

  function allBricksCleared() {
    if (!bricks || !bricks.length) return false;
    for (const br of bricks) if (!br.hit) return false;
    return true;
  }

  Features.update = function update(dt) {
    if (S.mode === "paused") return;

    if (S.mode === "gameover") {
      S.gameOverT -= dt;
      if (S.gameOverT <= 0) Features.restartGame();
      return;
    }

    if (S.mode === "levelclear") {
      S.levelClearT -= dt;
      if (S.levelClearT <= 0) Features.startLevel(S.level + 1);
      return;
    }

    const t = nowSec();
    if (S.basePaddleW != null && t > S.effects.enlargeUntil) {
      paddle.w = S.basePaddleW;
      paddle.x = clamp(paddle.x, 0, W - paddle.w);
    }

    // falling powerups
    for (let i = S.spawnedPowerups.length - 1; i >= 0; i--) {
      const pu = S.spawnedPowerups[i];
      pu.y += pu.vy * dt;
      if (rectsOverlap(pu.x - pu.r, pu.y - pu.r, pu.r*2, pu.r*2, paddle.x, paddle.y, paddle.w, paddle.h)) {
        applyPowerup(pu.type);
        S.spawnedPowerups.splice(i, 1);
        continue;
      }
      if (pu.y > H + 60) S.spawnedPowerups.splice(i, 1);
    }

    updateLasers(dt);

    if (allBricksCleared()) {
      S.mode = "levelclear";
      S.levelClearT = CFG.levelClearDelay;
      score += 50 * S.level;
    }
  };

  Features.drawBricks = function drawBricks(ctx) {
    for (const br of bricks) {
      if (br.hit) continue;
      const color = br.color || "#ff69b4";
      const shape = br.shape || "rect";
      ctx.fillStyle = color;

      if (shape === "rounded") {
        roundRect(ctx, br.x, br.y, br.w, br.h, 7); ctx.fill();
        ctx.fillStyle = "#111";
        roundRect(ctx, br.x+6, br.y+6, br.w-12, br.h-12, 3); ctx.fill();
      } else if (shape === "pill") {
        roundRect(ctx, br.x, br.y, br.w, br.h, br.h/2); ctx.fill();
        ctx.fillStyle = "#111";
        roundRect(ctx, br.x+6, br.y+6, br.w-12, br.h-12, Math.max(2,(br.h-12)/2)); ctx.fill();
      } else if (shape === "triangle") {
        ctx.beginPath();
        ctx.moveTo(br.x + br.w/2, br.y);
        ctx.lineTo(br.x + br.w, br.y + br.h);
        ctx.lineTo(br.x, br.y + br.h);
        ctx.closePath(); ctx.fill();

        ctx.fillStyle = "#111";
        ctx.beginPath();
        ctx.moveTo(br.x + br.w/2, br.y+6);
        ctx.lineTo(br.x + br.w - 6, br.y + br.h - 6);
        ctx.lineTo(br.x+6, br.y + br.h - 6);
        ctx.closePath(); ctx.fill();
      } else {
        ctx.fillRect(br.x, br.y, br.w, br.h);
        ctx.fillStyle = "#111";
        ctx.fillRect(br.x+6, br.y+6, br.w-12, br.h-12);
      }

      if (typeof br.hp === "number" && br.hp > 1) {
        ctx.fillStyle = "#fff";
        ctx.font = "12px Arial";
        ctx.fillText(String(br.hp), br.x + 6, br.y + 15);
      }
    }
  };

  Features.drawFlipperLeg = function drawFlipperLeg(ctx, f, isLeft) {
    // Pivot convention consistent with your flipper collision:
    const pivotX = f.x + f.w / 2;
    const pivotY = f.y + 10;

    ctx.save();
    ctx.translate(pivotX, pivotY);
    ctx.rotate(f.angle);

    // Mirror: left foot toe points right (inward), right foot toe points left (inward)
    const dir = isLeft ? 1 : -1;

    const legH = f.h;
    const shinW = Math.max(16, f.w * 1.9);
    const calfBulge = shinW * 0.28;

    // --- LEG OUTLINE (closer to your reference) ---
    ctx.fillStyle = "#ffd1dc";
    ctx.beginPath();

    // Start near top outer edge
    ctx.moveTo(-shinW * 0.35, 0);

    // Outer contour: slight calf bulge
    ctx.bezierCurveTo(
      -shinW * 0.55, legH * 0.20,
      -shinW * 0.55, legH * 0.45,
      -shinW * 0.32 - calfBulge, legH * 0.62
    );

    // Outer to ankle
    ctx.bezierCurveTo(
      -shinW * 0.28, legH * 0.78,
      -shinW * 0.42, legH * 0.90,
      -shinW * 0.20, legH * 0.98
    );

    // Bottom ankle curve to inner
    ctx.bezierCurveTo(
      -shinW * 0.05, legH * 1.02,
       shinW * 0.05, legH * 1.02,
       shinW * 0.20, legH * 0.98
    );

    // Inner contour: straighter line up
    ctx.bezierCurveTo(
       shinW * 0.40, legH * 0.88,
       shinW * 0.30, legH * 0.45,
       shinW * 0.20, legH * 0.18
    );

    // Close at top
    ctx.bezierCurveTo(
       shinW * 0.15, legH * 0.06,
      -shinW * 0.10, 0,
      -shinW * 0.35, 0
    );

    ctx.closePath();
    ctx.fill();

    // Outline stroke for "inked" look like your reference
    ctx.lineWidth = 3;
    ctx.strokeStyle = "#111";
    ctx.stroke();

    // --- SHOE (high heel) ---
    const footY = legH * 0.98;

    // Shoe upper
    ctx.fillStyle = "#fff";
    ctx.beginPath();
    ctx.moveTo(dir * (-shinW * 0.10), footY - 10);
    ctx.lineTo(dir * ( shinW * 0.55), footY - 2);
    ctx.lineTo(dir * ( shinW * 0.62), footY + 10);
    ctx.lineTo(dir * (-shinW * 0.18), footY + 6);
    ctx.closePath();
    ctx.fill();
    ctx.strokeStyle = "#111";
    ctx.stroke();

    // Sole + toe
    ctx.fillStyle = "#fff";
    ctx.beginPath();
    ctx.moveTo(dir * (-shinW * 0.22), footY + 6);
    ctx.lineTo(dir * ( shinW * 0.75), footY + 10); // pointed toe inward
    ctx.lineTo(dir * ( shinW * 0.55), footY + 18);
    ctx.lineTo(dir * (-shinW * 0.30), footY + 14);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();

    // Heel (stiletto)
    ctx.beginPath();
    ctx.moveTo(dir * (-shinW * 0.02), footY + 10);
    ctx.lineTo(dir * (-shinW * 0.14), footY + 36);
    ctx.lineTo(dir * (-shinW * 0.22), footY + 34);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();

    // Pink strap accent
    ctx.fillStyle = "#ff69b4";
    ctx.fillRect(-shinW * 0.18, legH * 0.22, shinW * 0.36, 5);

    ctx.restore();
  };

  Features.draw = function draw(ctx) {
    // pickups
    for (const pu of S.spawnedPowerups) {
      ctx.fillStyle = ({ multiball:"#ffee66", laser:"#66ddff", enlarge:"#88ff88", slow:"#ff88ff" })[pu.type] || "#fff";
      ctx.beginPath();
      ctx.arc(pu.x, pu.y, pu.r, 0, Math.PI*2);
      ctx.fill();
      ctx.fillStyle = "#111";
      ctx.font = "10px Arial";
      ctx.fillText(pu.type[0].toUpperCase(), pu.x - 4, pu.y + 4);
    }

    // lasers
    for (const L of S.lasers) {
      ctx.fillStyle = "#66ddff";
      ctx.fillRect(L.x, L.y, L.w, L.h);
    }

    // overlays
    if (S.mode === "paused" || S.mode === "levelclear" || S.mode === "gameover") {
      ctx.fillStyle = "rgba(0,0,0,0.55)";
      ctx.fillRect(W/2 - 160, H/2 - 52, 320, 104);
      ctx.fillStyle = "#fff";
      ctx.font = "26px Arial";

      if (S.mode === "paused") ctx.fillText("PAUSED", W/2 - 62, H/2 - 6);
      if (S.mode === "levelclear") ctx.fillText(`LEVEL ${S.level} CLEAR`, W/2 - 106, H/2 - 6);
      if (S.mode === "gameover") ctx.fillText("GAME OVER", W/2 - 88, H/2 - 6);

      ctx.font = "14px Arial";
      if (S.mode === "paused") ctx.fillText("Press P or tap Pause to resume", W/2 - 108, H/2 + 24);
      if (S.mode === "levelclear") ctx.fillText("Next level incoming...", W/2 - 72, H/2 + 24);
      if (S.mode === "gameover") ctx.fillText("Restarting...", W/2 - 42, H/2 + 24);
    }
  };

  function ensurePauseButton() {
    let btn = document.getElementById("pauseBtn");
    if (!btn) {
      btn = document.createElement("button");
      btn.id = "pauseBtn";
      btn.textContent = "Pause";
      btn.style.position = "absolute";
      btn.style.right = "12px";
      btn.style.bottom = "12px";
      btn.style.zIndex = 9999;
      btn.style.padding = "9px 12px";
      btn.style.background = "#ff69b4";
      btn.style.color = "#111";
      btn.style.border = "none";
      btn.style.borderRadius = "10px";
      btn.style.fontFamily = "Arial, sans-serif";
      btn.style.fontWeight = "700";
      btn.style.cursor = "pointer";
      document.body.appendChild(btn);
    }
    btn.onclick = () => Features.togglePause();
  }

  window.addEventListener("keydown", (e) => {
    const k = e.key.toLowerCase();
    if (k === "p") Features.togglePause();
    if (k === " " || k === "k") Features.shootLaser();
  });

  window.addEventListener("load", () => {
    ensurePauseButton();
    // Initialize first level automatically
    Features.startLevel(1);
  });
})();


/* ------------------ MAIN LOOP ------------------ */
let last = performance.now();
function tick(now){
  let dt = (now - last) / 1000;
  last = now;

  // clamp dt to prevent huge physics jumps (tab-switch, lag spike, etc.)
  dt = Math.min(dt, 1/30);

  // slow-time powerup scales simulation cleanly
  const timeScale = window.Features?.getTimeScale?.() ?? 1;
  dt *= timeScale;

  update(dt);
  draw();
  requestAnimationFrame(tick);
}
requestAnimationFrame(tick);
</script>
</body>
</html>
